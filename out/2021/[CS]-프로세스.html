<!DOCTYPE html><html lang="ko"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>[CS] 프로세스</title><meta name="robots" content="index,follow"/><meta property="og:title" content="[CS] 프로세스"/><meta property="og:url" content="https://kimjeongwonn.github.io/2021/%5BCS%5D-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"/><meta property="og:type" content="article"/><meta property="og:locale" content="ko_KR"/><meta property="og:site_name" content="kimjeongwonn blog"/><meta name="next-head-count" content="9"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"/><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard-dynamic-subset.css"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/c2a527101433f11d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2a527101433f11d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-5752944655d749a0.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-faec98bce91d71b6.js" defer=""></script><script src="/_next/static/chunks/962-69674526bb4c5f05.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bslug%5D-e296581b13b92cd8.js" defer=""></script><script src="/_next/static/7_nLpp8ghi2rTktMODD63/_buildManifest.js" defer=""></script><script src="/_next/static/7_nLpp8ghi2rTktMODD63/_ssgManifest.js" defer=""></script><script src="/_next/static/7_nLpp8ghi2rTktMODD63/_middlewareManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;800&display=swap">@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbY2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKxjPg.woff) format('woff')}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:800;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbY2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8SKtjPg.woff) format('woff')}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx3cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxTcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxPcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx_cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx7cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxDcwgknk-4.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:800;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx3cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:800;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxTcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:800;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxPcwgknk-6nFg.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:800;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx_cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:800;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx7cwgknk-6nFg.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'JetBrains Mono';font-style:normal;font-weight:800;font-display:swap;src:url(https://fonts.gstatic.com/s/jetbrainsmono/v11/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxDcwgknk-4.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next" data-reactroot=""><style data-emotion="css-global tp5msl">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline;}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block;}body{line-height:1;}ol,ul{list-style:none;}blockquote,q{quotes:none;}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none;}table{border-collapse:collapse;border-spacing:0;}html{font-family:Pretendard,sans-serif;background-color:#fff;color:#000;overscroll-behavior-y:none;overflow-y:auto;}body{line-height:1.5;}a{-webkit-text-decoration:none;text-decoration:none;color:#000;}a:visited{all:unset;}</style><style data-emotion="css 1r7aulx">.css-1r7aulx{max-width:768px;min-height:100vh;position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;border-left:1px solid #000;border-right:1px solid #000;margin:0 auto;}@media screen and (max-width: 768px){.css-1r7aulx{border-left:none;border-right:none;}}</style><div class="css-1r7aulx"><style data-emotion="css vwll15">.css-vwll15{position:-webkit-sticky;position:sticky;top:0;padding:20px;border-bottom:1px solid #000;background-color:#fff;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-transform:translateY(0px);-moz-transform:translateY(0px);-ms-transform:translateY(0px);transform:translateY(0px);-webkit-transition:-webkit-transform 0.4s;transition:transform 0.4s;}</style><header class="css-vwll15"><style data-emotion="css 167z7h7">.css-167z7h7{font-family:JetBrains Mono;font-weight:700;font-size:18px;color:#000;line-height:1;}</style><a href="/" class="css-167z7h7">kimjeongwonn</a><style data-emotion="css ugbd65">.css-ugbd65{display:block;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none;appearance:none;margin:0;margin-top:8px;padding:0;background:none;border:none;font-family:JetBrains Mono;font-size:18px;line-height:1;cursor:pointer;width:-webkit-max-content;width:-moz-max-content;width:max-content;}</style><a href="/about" class="css-ugbd65">about</a></header><style data-emotion="css 1t5arkg">.css-1t5arkg{position:fixed;top:20px;right:20px;}</style><ul class="css-1t5arkg"></ul><main class="css-1xdhyk6"><style data-emotion="css 1wwqe1d">.css-1wwqe1d{padding:20px;max-width:480px;color:#000;}</style><article class="css-1wwqe1d"><style data-emotion="css 1dafvn8">.css-1dafvn8{padding-bottom:20px;margin-bottom:20px;border-bottom:1px solid #000;}</style><header class="css-1dafvn8"><style data-emotion="css 1o3wa7v">.css-1o3wa7v{display:block;font-size:14px;margin-bottom:10px;}</style><time class="css-1o3wa7v">2021/08/17</time><style data-emotion="css 1i81doc">.css-1i81doc{font-size:36px;font-weight:700;}</style><h1 class="css-1i81doc">[CS] 프로세스</h1></header><style data-emotion="css 13eqh6l">.css-13eqh6l{color:#000;font-size:16px;line-height:1.8;word-break:keep-all;overflow-wrap:break-word;}.css-13eqh6l hr{border:none;border-bottom:1px solid #eaeaea;margin:16px 0;}.css-13eqh6l ul li{margin-left:32px;list-style:disc;}.css-13eqh6l ul li li{list-style:circle;}.css-13eqh6l ul li li li{list-style:square;}.css-13eqh6l ol li{list-style:decimal;margin-left:32px;}.css-13eqh6l h2{font-size:28px;font-weight:700;margin:12px 0;border-bottom:1px solid #eaeaea;}.css-13eqh6l h3{font-size:22px;font-weight:700;margin-top:8px;}.css-13eqh6l h4{font-size:18px;font-weight:700;margin-top:8px;}.css-13eqh6l h5,.css-13eqh6l h6{font-weight:700;margin-top:6px;}.css-13eqh6l p{margin-block-start:1ch;margin-block-end:1ch;}.css-13eqh6l strong{font-weight:700;}.css-13eqh6l em{font-style:italic;}.css-13eqh6l blockquote{border-left:4px solid #eaeaea;line-height:1.5;padding:4px 0;padding-left:12px;}.css-13eqh6l pre{font-family:JetBrains Mono,monospace;padding:12px;background-color:#f5f5f5;border-radius:4px;line-height:1.5;overflow-x:auto;}.css-13eqh6l pre code{all:unset;font-size:14px;}.css-13eqh6l code{font-family:JetBrains Mono,monospace;line-height:1;padding:2px 4px;background-color:#f5f5f5;border-radius:4px;font-size:14px;margin:0 2px;}.css-13eqh6l img{max-width:100%;}</style><section class="css-13eqh6l"><h2>스케쥴러</h2>
<h3>배치 처리 시스템</h3>
<ul>
<li>시스템이 여러개의 프로그램을 순차적으로 처리하는 방식
<ul>
<li>Queue 자료구조와 비슷한 방식으로 동작</li>
</ul>
</li>
<li>하나의 프로그램이 실행되는 동안 다른 작업을 하지 못함 → 한 번에 하나의 프로그램 처리만 가능</li>
</ul>
<h3>멀티 태스킹</h3>
<ul>
<li>단일 CPU에서 다수의 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 방법</li>
</ul>
<h4>시 분할 시스템</h4>
<ul>
<li>시간단위로 아주 잘게 분할해서 여러가지 프로그램을 번갈아가면서 처리하는 방식</li>
<li>다중 사용자가 시스템을 사용할 수 있으며, 입력에 대한 응답시간을 최소화 할 수 있음</li>
</ul>
<h4>멀티 태스킹과 멀티 프로세싱</h4>
<ul>
<li>멀티 태스킹은 단일 CPU가 시분할 시스템을 이용해 동시에 여러가지 프로그램을 처리하는 것</li>
<li>멀티 프로세싱은 다중 CPU가 하나의 프로그램을 병렬로 처리하는 것</li>
</ul>
<h4>멀티 프로그래밍</h4>
<ul>
<li>응용 프로그램은 CPU만 사용하는 것이 아니라, 다른 작업을 중간에 필요로 하는 경우가 많음
<ul>
<li>예) 저장 매체 사용, 입력 장치, 출력 장치 사용 등</li>
</ul>
</li>
<li>하나의 응용프로그램이 CPU 외의 장치를 사용하면서 CPU를 사용하지 않으면서 점유할 때 다른 프로그램에서 CPU를 사용할 수 있도록 해서 CPU가 낭비되는 시간이 없도록 한다.</li>
<li>CPU를 최대한 효율적으로 활용하도록 하는 시스템</li>
</ul>
<h3>프로세스</h3>
<ul>
<li>실행중인 프로그램의 실행단위 → 메모리 위에 올라가 있는 프로그램
<ul>
<li>코드 이미지(바이너리): 실행 파일</li>
</ul>
</li>
<li><code>작업</code>, <code>Task</code>, <code>Job</code> 등 용어를 혼용하여 사용한다.</li>
<li>응용 프로그램 ≠ 프로세스
<ul>
<li>응용 프로그램은 여러개의 프로세스로 이루어질 수 있음</li>
<li>하나의 응용 프로그램이 기능을 처리하기 위해 다수의 프로세스가 상호작용하여 실행될 수 있음</li>
</ul>
</li>
</ul>
<h3>스케쥴러</h3>
<ul>
<li>스케쥴러는 프로세스의 실행을 단위별로 관리한다.</li>
</ul>
<h4>스케쥴링 알고리즘</h4>
<ul>
<li>프로세스를 실행시키는 순서와 방법을 결정하는 알고리즘</li>
<li>시 분할 시스템을 구현 → 프로세스 응답 시간을 최대한 짧게</li>
<li>멀티 프로그래밍을 구현 → CPU의 활용도를 최대한 높여서 효율적으로</li>
</ul>
<h4>FIFO 스케쥴러</h4>
<ul>
<li>프로세스를 처음부터 끝까지 순차적으로 처리하는 가장 간단한 스케줄러</li>
<li>배치 처리 시스템과 가장 유사</li>
<li>FCFS(First Come First Served) 스케쥴러라고 부르기도 함</li>
</ul>
<h4>SFJ 스케쥴러</h4>
<ul>
<li>Shortest Job First 스케쥴러 → 최단 작업 우선</li>
<li>프로세스의 작업 시간을 알고 있을 때 가장 빠른 프로세스를 먼저 처리하는 스케줄러</li>
<li>장점
<ul>
<li>FIFO 스케쥴러 보다 응답시간이 짧을 수 있음</li>
<li>같은 시간 내에 더 많은 프로세스를 처리할 수 있음</li>
</ul>
</li>
<li>단점
<ul>
<li>프로세스의 작업 시간을 미리 모두 알아야 함</li>
<li>작업 시간이 오래 걸리는 프로세스는 계속해서 우선순위가 뒤로 밀리게 됨</li>
</ul>
</li>
</ul>
<h4>우선순위 기반 스케쥴러</h4>
<ul>
<li>Priority-Based 스케쥴러</li>
<li>우선순위를 정하는 기준은 정적 우선순위, 동적 우선순위가 있다</li>
<li>정적 우선순위
<ul>
<li>프로세스마다 우선순위를 미리 지정한다</li>
</ul>
</li>
<li>동적 우선순위
<ul>
<li>스케쥴러가 상황에 따라 우선순위를 동적으로 변경한다</li>
<li>시스템이 목표하는 기준에 맞춰 이전에 처리한 내용을 기반으로 우선순위를 결정한다.</li>
</ul>
</li>
</ul>
<h4>Round Robin 스케쥴러</h4>
<ul>
<li>시 분할 시스템을 기반으로 동작하는 스케쥴러</li>
<li>대기 큐에 있는 프로세스를 FCFS 방식으로 처리한다.</li>
<li>지정된 시간 내에 프로세스가 모두 처리가 되지 않으면 다시 대기 큐에 넣는다.</li>
</ul>
<h2>상태</h2>
<ul>
<li>프로세스 스케쥴러의 스케쥴링 알고리즘이 동작하기 위해서는 반드시 프로세스의 상태를 알 수 있어야 한다.</li>
<li>프로세스의 상태는 다음과 같이 정의되어 있다.
<ul>
<li>프로세스 생성 <code>new</code>
<ul>
<li>프로세스를 초기화 하고 있는 상태이므로 ready상태가 되면 실행 가능하다.</li>
</ul>
</li>
<li>실행 가능 <code>ready</code>
<ul>
<li>CPU에서 바로 실행이 가능한 상태</li>
<li>스케쥴러의 대상이 된다.</li>
</ul>
</li>
<li>실행 중 <code>running</code>
<ul>
<li>현재 CPU에서 작업중인 프로세스의 상태</li>
<li>코어별로 최대 1개의 상태를 가질 수 있다.</li>
<li>스케쥴러가 결정한다.</li>
</ul>
</li>
<li>대기 <code>blocked</code>
<ul>
<li>특정 이벤트가 발생하기를 대기하는 상태</li>
<li>예를 들어서 파일 읽기를 저장장치에 요청했다면, 파일 읽기 완료 이벤트가 발생할 때 까지 대기상태로 <code>blocked</code>되어 있다가, 이벤트가 발생하면 다시 <code>ready</code>가 된다.</li>
</ul>
</li>
<li>종료 <code>exit</code>
<ul>
<li>프로세스가 사용했떤 자원을 반납하기 위해 처리중인 상태</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>프로세스 상태 기반 스케쥴링</h3>
<ul>
<li>스케쥴러는 프로세스의 상태만 보고 스케쥴링을 결정하기는 어렵기 때문에 정책이 필요함</li>
<li><code>ready</code>, <code>running</code>, <code>blocked</code>상태별로 큐를 만들어서 프로세스를 관리할 수 있음
<ul>
<li><code>ready</code> 큐에 있는 프로세스를 계속 <code>dequeue</code>하여 처리하는 것을 반복 <code>running</code>큐에 <code>enqueue</code></li>
<li>프로세스가 대기(blocked)하게 된다면 그 동안 <code>blocked</code>큐에 넣어 <code>ready</code>큐에 들어가지 않음</li>
</ul>
</li>
<li>이 과정의 반복을 통해 효율적으로 실행 가능한 프로세스를 처리하여 멀티 프로그래밍이 가능</li>
</ul>
<h4>선점형 스케쥴러</h4>
<ul>
<li>하나의 프로세스가 CPU에서 running 상태로 동작하고 있는 중에 다른 프로세스가 선점하여 처리할 수 있음</li>
<li>시분할 시스템 구현 가능</li>
<li>RoundRobin 스케쥴러</li>
</ul>
<h4>비선점형 스케쥴러</h4>
<ul>
<li>하나의 프로세스가 end 상태가 되거나 blocked 상태가 될 때 까지 다른 프로세스가 선점하여 처리할 수 없음</li>
<li>FCFS, SJF, Priority-based 스케쥴러</li>
</ul>
<h4>스케쥴링 알고리즘 조합</h4>
<ul>
<li>운영체제는 다양한 스케쥴링 알고리즘을 조합한 스케쥴러로 동작한다.</li>
<li>예) RoundRobin + Priority-based
<ul>
<li>우선순위를 갖는 시분할 스케쥴러</li>
</ul>
</li>
</ul>
<h2>인터럽트</h2>
<ul>
<li>CPU가 작업을 처리중인 상황에 하드웨어나 소프트웨어의 이벤트 발생, 예외상황 발생 처리를 위해 CPU에 알려주는 기술</li>
<li>일종의 이벤트로 볼 수 있음</li>
</ul>
<h3>인터럽트가 필요한 이유</h3>
<ul>
<li>선점형 스케쥴러의 구현을 위해서는 running 상태의 프로세스를 중단시키고 다른 프로세스로 교체해야 함
<ul>
<li>이를 위해 스케쥴러 코드가 인터럽트를 통해 현재 실행중인 프로세스를 중단 시켜야 함</li>
</ul>
</li>
<li>입출력 장치의 처리 혹은 예외상황(0으로 나누기 등)이 발생했을 때 CPU에서 해당 상황에 대한 처리를 위해 인터럽트를 통해 알릴 수 있음</li>
</ul>
<h3>인터럽트의 종류</h3>
<h4>내부 인터럽트 (소프트웨어 인터럽트)</h4>
<ol>
<li>Divide-by-Zero 인터럽트 : 0으로 나누는 명령 실행 시 발생하는 인터럽트</li>
</ol>
<ul>
<li>사용자 모드에서 잘못된 공간 접근 시
<ul>
<li>프로세스는 4GB의 메모리를 사용할 수 있는데 사용자 모드에서는 0GB~3GB, 커널모드에서는 3GB~4GB에 접근할 수 있음</li>
</ul>
</li>
<li>계산 결과에서 Overflow 혹은 Underflow가 발생할 때</li>
</ul>
<h4>외부 인터럽트 (하드웨어 인터럽트)</h4>
<ol>
<li>타이머 인터럽트 : 선점형 스케쥴러를 구현하기 위해 일정 시간마다 인터럽트를 계속 발생시켜 현재 처리해야 하는 프로세스를 결정할 수 있음</li>
<li>입출력 인터럽트 : 입출력 장치(키보드, 마우스, 저장매체, 프린터 등)에서 작업을 처리하고 완료됐음을 알려서 후속 처리를 할 수 있음</li>
</ol>
<h3>인터럽트 동작</h3>
<h4>시스템 콜 인터럽트</h4>
<ul>
<li>시스템 콜을 실행하기 위해 인터럽트 명령을 넣어 실행시켜야 한다. → 커널 모드로 전환을 위해
<ul>
<li>eax 레지스터에 시스템 콜 번호를, ebx 레지스터에 인자값을 넣고 소프트웨어 인터럽트를 호출하면서 시스템콜에 해당하는 0x80값을 넘겨서 호출</li>
<li>CPU가 커널모드로 IDT에서 0x80에 해당하는 함수(시스템 콜)를 실행</li>
<li>시스템 콜 함수가 eax 레지스터에 저장된 시스템 콜 번호를 통해 원하는 시스템 콜 호출</li>
<li>함수 실행 후, 다시 사용자 모드로 변경하고 다시 해당 프로세스 다음코드 실행</li>
</ul>
</li>
</ul>
<h4>IDT</h4>
<ul>
<li>인터럽트는 미리 정의되어 있는 실행코드의 주소를 IDT에 저장하고 있음</li>
<li>컴퓨터 부팅 시 운영체제가 커널 영역에 IDT영역을 초기화하고 정의함</li>
<li>리눅스 기준으로 아래와 같이 구분되어 있음
<ul>
<li>0 ~ 31 : 예외상황 인터럽트</li>
<li>32 ~ 47 : 하드웨어 인터럽트</li>
<li>128(<code>0x80</code>) : 시스템 콜</li>
</ul>
</li>
</ul>
<h2>컨텍스트 스위칭</h2>
<h3>프로세스의 구조</h3>
<ul>
<li>코드가 컴파일 되면서 기계어로 전환되어 실행파일로 만들어 진다.</li>
<li>실행 파일을 실행하면 프로세스가 생성되고 프로세스 내부에 코드 영역에 기계어로 변환 된 코드가 올라간다.</li>
<li>코드 영역의 코드를 실행하고 코드 내부에서 전역으로 선언 된 변수는 데이터 영역에 저장된다</li>
<li>함수가 실행되고 내부에서 선언된 매개변수, 변수는 함수 반환 시 메모리 함께 사라지기 때문에 스택 영역에 저장된다.
<ul>
<li>함수가 실행 될 때 함수가 반환되고 이동할 Return Address를 먼저 Push한다.</li>
<li>차례대로 매개변수와 변수를 Push한다.</li>
<li>함수가 종료되면 차례대로 Pop하고 마지막에 Return Address가 Pop되면 해당 주소로 이동한다.</li>
</ul>
</li>
<li>프로세스 내에서 동적인 데이터를 담는 메모리 공간이 필요할 때 힙 영역에 저장된다.</li>
<li>코드 영역과 데이터 영역은 프로세스 생성시 정적으로 결정된다.</li>
<li>스택 영역은 프로세스 메모리주소의 최대값 부터 힙 영역은 코드영역 다음부터 정의되며 동적으로 할당된다.</li>
</ul>
<h4>프로세스 레지스터</h4>
<ul>
<li>PC(Program counter) : 코드가 실행되는 주소값을 저장하는 레지스터</li>
<li>SP(Stack Pointer) : 현재 스택의 Top주소를 저장하는 레지스터</li>
<li>EBP : 함수가 호출되면 EBP에서 함수가 시작되는 부분을 기록해서 예외가 발생했을 때 예외가 발생한 함수를 특정할 수 있게 해 주는 레지스터</li>
<li>EAX : 함수의 반환값을 저장하는 레지스터</li>
</ul>
<h3>힙 영역</h3>
<ul>
<li>동적인 메모리의 공간을 관리하는 영역</li>
<li>힙 영역의 주소값을 스택 영역에 저장하여 변수에 할당할 수 있음</li>
</ul>
<h3>데이터 영역</h3>
<ul>
<li>데이터 영역은 두가지로 구분된다.</li>
<li>BSS : 초기화되지 않은 전역변수
<ul>
<li>코드 내에서 선언만 했을 경우</li>
</ul>
</li>
<li>DATA : 초기값이 있는 전역변수
<ul>
<li>코드 내에서 선언과 함께 초기값을 할당했을 경우</li>
</ul>
</li>
</ul>
<h2>컨텍스트 스위칭</h2>
<ul>
<li>스케쥴러가 running 상태의 프로세스를 바꿀 때 두 프로세스에서 상태를 변경하는 방법</li>
<li>A → B 로 컨텍스트 스위칭이 일어나면 현재 레지스터의 PC와 SP를 <code>PCB(Process Control Block)</code>에 저장해서 현재 실행중인 상태를 보관할 수 있음</li>
<li>B → A 로 다시 컨텍스트 스위칭이 일어나면 PCB를 확인해서 저장된 PC와 SP를 레지스터에 덮어씌워 이전에 진행하던 상태로 돌아옴</li>
</ul>
<h4>PCB</h4>
<ul>
<li>프로세스가 실행중인 상태를 캡쳐/구조화 해서 저장하는 공간</li>
<li>프로세스ID, 레지스터 값(PC, SP 등), 스케쥴링 상태 정보, 메모리 정보 등을 저장</li>
<li>컨텍스트 스위칭은 매우 자주일어나고 오버헤드등으로 지연될 경우 성능 전체에 영향을 주기 때문에 동작이 어셈블리어로 작성되어 있음</li>
</ul>
<h2>프로세스간 커뮤니케이션</h2>
<ul>
<li>프로세스간의 공간은 완전히 분리되어 있음</li>
<li>다른 프로세스간의 상호 접근하는 방법은 보안상의 이유로 제공되지 않음</li>
<li>필요한 경우 프로세스간의 통신을 할 수 있는 IPC(InterProcess Communication)라는 방법을 제공함</li>
</ul>
<h4><code>fork()</code> 시스템 콜</h4>
<ul>
<li><code>fork()</code> 시스템 콜을 통해 하나의 프로세스를 복사하여 새로운 프로세스를 만들 수 있음</li>
<li>복사된 프로세스와 통신하기 위해서는 IPC를 사용해야 함</li>
</ul>
<h4>프로세스간 통신이 필요한 이유</h4>
<ul>
<li>하나의 프로그램을 다수의 프로세스를 사용해 구동시켜 효율적으로 프로세서를 사용할 수 있게됨 (멀티코어 프로세스에서 각 코어별로 프로세스를 병렬로 동작)</li>
<li>이 때 다른 코어에서 작동하는 프로세스간의 상태 확인 및 데이터 송수신이 필요</li>
</ul>
<h4>프로세스 가상메모리의 커널영역</h4>
<ul>
<li>각 프로세스는 가상메모리로 4GB씩 할당받는다. 이는 실제 물리메모리에 올라가는 크기가 아니라 프로세스 내에서 활용할 수 있는 공간을 가상으로 할당한 영역이다.</li>
<li>이 때 0~3GB는 프로세스가 사용하는 공간 3~4GB는 운영체제 커널이 할당된 공간이다</li>
<li>커널 영역은 실제 물리메모리에 올라갈 때 모든 프로세스가 같은 공간을 공유하게 되어있음</li>
<li>이 영역을 활용해서 IPC가 가능</li>
</ul>
<h3>IPC 기법</h3>
<h4>파일을 사용한 커뮤니케이션</h4>
<ul>
<li>각 프로세스 별로 처리한 내용을 파일에 저장해서 공유하는 방법</li>
<li>실시간으로 원하는 프로세스에 전달하기 어려움</li>
<li>저장매체를 사용하기 때문에 효율이 떨어짐</li>
<li>커널영역을 사용하지 않는 방법으로 사용성이 매우 떨어짐</li>
</ul>
<h4>Pipe</h4>
<ul>
<li><code>fork()</code>를 통해 복사된 프로세스를 향해 단방향으로 데이터를 전달할 수 있음</li>
<li><code>pipe()</code> 시스템 콜에 배열을 전달하면 배열의 1번 인덱스에 작성한 내용을 0번 인덱스에서 읽을 수 있음
<ul>
<li>단방향 통신이기 때문에 1에서 작성해서 0에서 읽는 건 가능하나, 0에서 작성해서 1로(역방향) 가는 것은 불가능하다</li>
</ul>
</li>
</ul>
<h4>메세지 큐 (Message Queue)</h4>
<ul>
<li>모든 프로세스 사이에서 양방향으로 데이터를 통신할 수 있음</li>
<li>FIFO 정책을 기반으로 데이터를 enqueue, dequeue하여 프로세스간 통신한다</li>
<li>메세지 큐를 생성하고 해당 큐의 key를 프로세스간에 공유하면 key를 통해 해당 큐에 접근할 수 있음</li>
</ul>
<h4>공유 메모리 (Shared Memory)</h4>
<ul>
<li>커널에 대놓고 메모리 영역을 만들고 해당 영역을 변수처럼 사용하는 방식</li>
<li>해당 공유 메모리의 key를 가지고 다수의 프로세스에서 접근할 수 있음</li>
</ul>
<h4>시그널 (Signal)</h4>
<ul>
<li>유닉스에서 30년 이상 사용하고 있는 커널 또는 프로세스에서 다른 프로세스로 이벤트 발생을 알려주는 기법</li>
<li>프로세스 관련 코드에 미리 시그널 핸들러를 등록하고 시그널을 받으면 해당 시그널 핸들러를 실행
<ul>
<li>프로그램에서 특정 시그널에 대한 동작을 임의로 지정해 줄 수 있음
<ul>
<li>해당 시그널을 무시</li>
<li>시그널 블록과 언블록을 통해 지연전달</li>
<li>특정 동작을 핸들러로 등록해서 임의로 지정</li>
<li>별도로 지정하지 않으면 커널의 기본 동작 수행</li>
</ul>
</li>
<li>지정되지 않는 시그널을 받으면 기본적으로 지정된 핸들러가 동작</li>
<li>프로세스의 PCB 내부에 해당 프로세스에서 블록된 혹은 처리해야하는 시그널에 관련 정보를 관리함</li>
<li>커널모드에서 사용자모드로 전환 할 때 PCB의 대기중인 시그널을 확인해 커널모드를 유지하는 경우도 있음</li>
</ul>
</li>
</ul>
<h4>소켓 (Socket)</h4>
<ul>
<li>서버와 클라이언트 등 두개의 다른 컴퓨터간 네트워크 기반 통신을 위한 기술</li>
<li>소켓을 시스템 콜로 사용해 하나의 컴퓨터 안에서 두 개의 프로세스간의 통신 기법으로 활용할 수 있음</li>
</ul>
<h2>마무리</h2>
<ul>
<li>하나의 코드를 실행하게 되면 다음의 단계를 따라 진행된다.
<ol>
<li>프로세스 생성 후 NEW 상태로 변경</li>
<li>메모리에 스택, 힙, 데이터(BBS, DATA), 코드 영역이 할당</li>
<li>소스코드 텍스트가 코드 영역에 입력</li>
<li>전역 변수를 데이터 영역에 입력</li>
<li>프로세의 상태를 READY 상태로 전환</li>
<li>스케쥴러에 의해 컨텍스트 스위칭이 일어나 RUNNING 상태로 전환</li>
<li>프로세스의 PCB를 불러와서 PC와 SP를 초기화</li>
<li>코드의 메인함수를 실행 → SP를 EBP에 저장, 다음 SP에 리턴 주소를 할당</li>
<li>함수내의 지역변수를 스택에 입력</li>
<li>함수내의 시스템 콜이 일어나게 되면 다음의 단계를 따라 진행된다.
<ol>
<li>시스템 콜의 번호와 시스템 콜의 인자를 EAX, EBX에 저장한 뒤, 0x80 주소로 시스템 콜 인터럽트를 실행</li>
<li>CPU의 모드가 커널 모드로 변경</li>
<li>IDT에서 0x80에 해당하는 주소의 함수를 찾아서 호출</li>
<li><code>system_call</code>함수에서 EAX에 저장된 시스템 콜의 번호를 찾아서, 해당 번호에 맞는 시스템 콜 함수로 이동</li>
<li>해당 시스템 콜 함수를 실행한 뒤, 다시 사용자 모드로 변경하고 프로세스의 다음 코드 진행</li>
<li>만약 시스템 콜 함수에 대기가 필요하다면 프로세스의 상태를 WAITING으로 변경 한다</li>
<li>시스템 콜의 처리가 끝나면 인터럽트를 통해 WAITING된 프로세스를 READY상태로 바꿔준다</li>
</ol>
</li>
<li>함수가 종료하게 될 때 반환값이 있다면 프로세스 레지스터의 EAX에 저장한 뒤 스택을 모두 POP한다.</li>
<li>리턴 어드레스를 POP하게 되면 해당 주소의 코드를 실행하고 만약 반환값을 사용한다면 EAX에 저장된 값을 사용한다</li>
<li>프로세스가 종료하게 되면 프로세스의 상태를 TERMINATED로 변경하고 종료한다.</li>
</ol>
</li>
</ul>
</section></article></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"[CS] 프로세스","createAt":"2021-08-17T08:29:30.000Z","content":"\u003ch2\u003e스케쥴러\u003c/h2\u003e\n\u003ch3\u003e배치 처리 시스템\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e시스템이 여러개의 프로그램을 순차적으로 처리하는 방식\n\u003cul\u003e\n\u003cli\u003eQueue 자료구조와 비슷한 방식으로 동작\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e하나의 프로그램이 실행되는 동안 다른 작업을 하지 못함 → 한 번에 하나의 프로그램 처리만 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e멀티 태스킹\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e단일 CPU에서 다수의 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 방법\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e시 분할 시스템\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e시간단위로 아주 잘게 분할해서 여러가지 프로그램을 번갈아가면서 처리하는 방식\u003c/li\u003e\n\u003cli\u003e다중 사용자가 시스템을 사용할 수 있으며, 입력에 대한 응답시간을 최소화 할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e멀티 태스킹과 멀티 프로세싱\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e멀티 태스킹은 단일 CPU가 시분할 시스템을 이용해 동시에 여러가지 프로그램을 처리하는 것\u003c/li\u003e\n\u003cli\u003e멀티 프로세싱은 다중 CPU가 하나의 프로그램을 병렬로 처리하는 것\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e멀티 프로그래밍\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e응용 프로그램은 CPU만 사용하는 것이 아니라, 다른 작업을 중간에 필요로 하는 경우가 많음\n\u003cul\u003e\n\u003cli\u003e예) 저장 매체 사용, 입력 장치, 출력 장치 사용 등\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e하나의 응용프로그램이 CPU 외의 장치를 사용하면서 CPU를 사용하지 않으면서 점유할 때 다른 프로그램에서 CPU를 사용할 수 있도록 해서 CPU가 낭비되는 시간이 없도록 한다.\u003c/li\u003e\n\u003cli\u003eCPU를 최대한 효율적으로 활용하도록 하는 시스템\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e프로세스\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e실행중인 프로그램의 실행단위 → 메모리 위에 올라가 있는 프로그램\n\u003cul\u003e\n\u003cli\u003e코드 이미지(바이너리): 실행 파일\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e작업\u003c/code\u003e, \u003ccode\u003eTask\u003c/code\u003e, \u003ccode\u003eJob\u003c/code\u003e 등 용어를 혼용하여 사용한다.\u003c/li\u003e\n\u003cli\u003e응용 프로그램 ≠ 프로세스\n\u003cul\u003e\n\u003cli\u003e응용 프로그램은 여러개의 프로세스로 이루어질 수 있음\u003c/li\u003e\n\u003cli\u003e하나의 응용 프로그램이 기능을 처리하기 위해 다수의 프로세스가 상호작용하여 실행될 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e스케쥴러\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e스케쥴러는 프로세스의 실행을 단위별로 관리한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e스케쥴링 알고리즘\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e프로세스를 실행시키는 순서와 방법을 결정하는 알고리즘\u003c/li\u003e\n\u003cli\u003e시 분할 시스템을 구현 → 프로세스 응답 시간을 최대한 짧게\u003c/li\u003e\n\u003cli\u003e멀티 프로그래밍을 구현 → CPU의 활용도를 최대한 높여서 효율적으로\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eFIFO 스케쥴러\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e프로세스를 처음부터 끝까지 순차적으로 처리하는 가장 간단한 스케줄러\u003c/li\u003e\n\u003cli\u003e배치 처리 시스템과 가장 유사\u003c/li\u003e\n\u003cli\u003eFCFS(First Come First Served) 스케쥴러라고 부르기도 함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eSFJ 스케쥴러\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eShortest Job First 스케쥴러 → 최단 작업 우선\u003c/li\u003e\n\u003cli\u003e프로세스의 작업 시간을 알고 있을 때 가장 빠른 프로세스를 먼저 처리하는 스케줄러\u003c/li\u003e\n\u003cli\u003e장점\n\u003cul\u003e\n\u003cli\u003eFIFO 스케쥴러 보다 응답시간이 짧을 수 있음\u003c/li\u003e\n\u003cli\u003e같은 시간 내에 더 많은 프로세스를 처리할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e단점\n\u003cul\u003e\n\u003cli\u003e프로세스의 작업 시간을 미리 모두 알아야 함\u003c/li\u003e\n\u003cli\u003e작업 시간이 오래 걸리는 프로세스는 계속해서 우선순위가 뒤로 밀리게 됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e우선순위 기반 스케쥴러\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003ePriority-Based 스케쥴러\u003c/li\u003e\n\u003cli\u003e우선순위를 정하는 기준은 정적 우선순위, 동적 우선순위가 있다\u003c/li\u003e\n\u003cli\u003e정적 우선순위\n\u003cul\u003e\n\u003cli\u003e프로세스마다 우선순위를 미리 지정한다\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e동적 우선순위\n\u003cul\u003e\n\u003cli\u003e스케쥴러가 상황에 따라 우선순위를 동적으로 변경한다\u003c/li\u003e\n\u003cli\u003e시스템이 목표하는 기준에 맞춰 이전에 처리한 내용을 기반으로 우선순위를 결정한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eRound Robin 스케쥴러\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e시 분할 시스템을 기반으로 동작하는 스케쥴러\u003c/li\u003e\n\u003cli\u003e대기 큐에 있는 프로세스를 FCFS 방식으로 처리한다.\u003c/li\u003e\n\u003cli\u003e지정된 시간 내에 프로세스가 모두 처리가 되지 않으면 다시 대기 큐에 넣는다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e상태\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e프로세스 스케쥴러의 스케쥴링 알고리즘이 동작하기 위해서는 반드시 프로세스의 상태를 알 수 있어야 한다.\u003c/li\u003e\n\u003cli\u003e프로세스의 상태는 다음과 같이 정의되어 있다.\n\u003cul\u003e\n\u003cli\u003e프로세스 생성 \u003ccode\u003enew\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e프로세스를 초기화 하고 있는 상태이므로 ready상태가 되면 실행 가능하다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e실행 가능 \u003ccode\u003eready\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003eCPU에서 바로 실행이 가능한 상태\u003c/li\u003e\n\u003cli\u003e스케쥴러의 대상이 된다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e실행 중 \u003ccode\u003erunning\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e현재 CPU에서 작업중인 프로세스의 상태\u003c/li\u003e\n\u003cli\u003e코어별로 최대 1개의 상태를 가질 수 있다.\u003c/li\u003e\n\u003cli\u003e스케쥴러가 결정한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e대기 \u003ccode\u003eblocked\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e특정 이벤트가 발생하기를 대기하는 상태\u003c/li\u003e\n\u003cli\u003e예를 들어서 파일 읽기를 저장장치에 요청했다면, 파일 읽기 완료 이벤트가 발생할 때 까지 대기상태로 \u003ccode\u003eblocked\u003c/code\u003e되어 있다가, 이벤트가 발생하면 다시 \u003ccode\u003eready\u003c/code\u003e가 된다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e종료 \u003ccode\u003eexit\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e프로세스가 사용했떤 자원을 반납하기 위해 처리중인 상태\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e프로세스 상태 기반 스케쥴링\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e스케쥴러는 프로세스의 상태만 보고 스케쥴링을 결정하기는 어렵기 때문에 정책이 필요함\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eready\u003c/code\u003e, \u003ccode\u003erunning\u003c/code\u003e, \u003ccode\u003eblocked\u003c/code\u003e상태별로 큐를 만들어서 프로세스를 관리할 수 있음\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eready\u003c/code\u003e 큐에 있는 프로세스를 계속 \u003ccode\u003edequeue\u003c/code\u003e하여 처리하는 것을 반복 \u003ccode\u003erunning\u003c/code\u003e큐에 \u003ccode\u003eenqueue\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e프로세스가 대기(blocked)하게 된다면 그 동안 \u003ccode\u003eblocked\u003c/code\u003e큐에 넣어 \u003ccode\u003eready\u003c/code\u003e큐에 들어가지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e이 과정의 반복을 통해 효율적으로 실행 가능한 프로세스를 처리하여 멀티 프로그래밍이 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e선점형 스케쥴러\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e하나의 프로세스가 CPU에서 running 상태로 동작하고 있는 중에 다른 프로세스가 선점하여 처리할 수 있음\u003c/li\u003e\n\u003cli\u003e시분할 시스템 구현 가능\u003c/li\u003e\n\u003cli\u003eRoundRobin 스케쥴러\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e비선점형 스케쥴러\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e하나의 프로세스가 end 상태가 되거나 blocked 상태가 될 때 까지 다른 프로세스가 선점하여 처리할 수 없음\u003c/li\u003e\n\u003cli\u003eFCFS, SJF, Priority-based 스케쥴러\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e스케쥴링 알고리즘 조합\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e운영체제는 다양한 스케쥴링 알고리즘을 조합한 스케쥴러로 동작한다.\u003c/li\u003e\n\u003cli\u003e예) RoundRobin + Priority-based\n\u003cul\u003e\n\u003cli\u003e우선순위를 갖는 시분할 스케쥴러\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e인터럽트\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCPU가 작업을 처리중인 상황에 하드웨어나 소프트웨어의 이벤트 발생, 예외상황 발생 처리를 위해 CPU에 알려주는 기술\u003c/li\u003e\n\u003cli\u003e일종의 이벤트로 볼 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e인터럽트가 필요한 이유\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e선점형 스케쥴러의 구현을 위해서는 running 상태의 프로세스를 중단시키고 다른 프로세스로 교체해야 함\n\u003cul\u003e\n\u003cli\u003e이를 위해 스케쥴러 코드가 인터럽트를 통해 현재 실행중인 프로세스를 중단 시켜야 함\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e입출력 장치의 처리 혹은 예외상황(0으로 나누기 등)이 발생했을 때 CPU에서 해당 상황에 대한 처리를 위해 인터럽트를 통해 알릴 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e인터럽트의 종류\u003c/h3\u003e\n\u003ch4\u003e내부 인터럽트 (소프트웨어 인터럽트)\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003eDivide-by-Zero 인터럽트 : 0으로 나누는 명령 실행 시 발생하는 인터럽트\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e사용자 모드에서 잘못된 공간 접근 시\n\u003cul\u003e\n\u003cli\u003e프로세스는 4GB의 메모리를 사용할 수 있는데 사용자 모드에서는 0GB~3GB, 커널모드에서는 3GB~4GB에 접근할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e계산 결과에서 Overflow 혹은 Underflow가 발생할 때\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e외부 인터럽트 (하드웨어 인터럽트)\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e타이머 인터럽트 : 선점형 스케쥴러를 구현하기 위해 일정 시간마다 인터럽트를 계속 발생시켜 현재 처리해야 하는 프로세스를 결정할 수 있음\u003c/li\u003e\n\u003cli\u003e입출력 인터럽트 : 입출력 장치(키보드, 마우스, 저장매체, 프린터 등)에서 작업을 처리하고 완료됐음을 알려서 후속 처리를 할 수 있음\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e인터럽트 동작\u003c/h3\u003e\n\u003ch4\u003e시스템 콜 인터럽트\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e시스템 콜을 실행하기 위해 인터럽트 명령을 넣어 실행시켜야 한다. → 커널 모드로 전환을 위해\n\u003cul\u003e\n\u003cli\u003eeax 레지스터에 시스템 콜 번호를, ebx 레지스터에 인자값을 넣고 소프트웨어 인터럽트를 호출하면서 시스템콜에 해당하는 0x80값을 넘겨서 호출\u003c/li\u003e\n\u003cli\u003eCPU가 커널모드로 IDT에서 0x80에 해당하는 함수(시스템 콜)를 실행\u003c/li\u003e\n\u003cli\u003e시스템 콜 함수가 eax 레지스터에 저장된 시스템 콜 번호를 통해 원하는 시스템 콜 호출\u003c/li\u003e\n\u003cli\u003e함수 실행 후, 다시 사용자 모드로 변경하고 다시 해당 프로세스 다음코드 실행\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eIDT\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e인터럽트는 미리 정의되어 있는 실행코드의 주소를 IDT에 저장하고 있음\u003c/li\u003e\n\u003cli\u003e컴퓨터 부팅 시 운영체제가 커널 영역에 IDT영역을 초기화하고 정의함\u003c/li\u003e\n\u003cli\u003e리눅스 기준으로 아래와 같이 구분되어 있음\n\u003cul\u003e\n\u003cli\u003e0 ~ 31 : 예외상황 인터럽트\u003c/li\u003e\n\u003cli\u003e32 ~ 47 : 하드웨어 인터럽트\u003c/li\u003e\n\u003cli\u003e128(\u003ccode\u003e0x80\u003c/code\u003e) : 시스템 콜\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e컨텍스트 스위칭\u003c/h2\u003e\n\u003ch3\u003e프로세스의 구조\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e코드가 컴파일 되면서 기계어로 전환되어 실행파일로 만들어 진다.\u003c/li\u003e\n\u003cli\u003e실행 파일을 실행하면 프로세스가 생성되고 프로세스 내부에 코드 영역에 기계어로 변환 된 코드가 올라간다.\u003c/li\u003e\n\u003cli\u003e코드 영역의 코드를 실행하고 코드 내부에서 전역으로 선언 된 변수는 데이터 영역에 저장된다\u003c/li\u003e\n\u003cli\u003e함수가 실행되고 내부에서 선언된 매개변수, 변수는 함수 반환 시 메모리 함께 사라지기 때문에 스택 영역에 저장된다.\n\u003cul\u003e\n\u003cli\u003e함수가 실행 될 때 함수가 반환되고 이동할 Return Address를 먼저 Push한다.\u003c/li\u003e\n\u003cli\u003e차례대로 매개변수와 변수를 Push한다.\u003c/li\u003e\n\u003cli\u003e함수가 종료되면 차례대로 Pop하고 마지막에 Return Address가 Pop되면 해당 주소로 이동한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e프로세스 내에서 동적인 데이터를 담는 메모리 공간이 필요할 때 힙 영역에 저장된다.\u003c/li\u003e\n\u003cli\u003e코드 영역과 데이터 영역은 프로세스 생성시 정적으로 결정된다.\u003c/li\u003e\n\u003cli\u003e스택 영역은 프로세스 메모리주소의 최대값 부터 힙 영역은 코드영역 다음부터 정의되며 동적으로 할당된다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e프로세스 레지스터\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003ePC(Program counter) : 코드가 실행되는 주소값을 저장하는 레지스터\u003c/li\u003e\n\u003cli\u003eSP(Stack Pointer) : 현재 스택의 Top주소를 저장하는 레지스터\u003c/li\u003e\n\u003cli\u003eEBP : 함수가 호출되면 EBP에서 함수가 시작되는 부분을 기록해서 예외가 발생했을 때 예외가 발생한 함수를 특정할 수 있게 해 주는 레지스터\u003c/li\u003e\n\u003cli\u003eEAX : 함수의 반환값을 저장하는 레지스터\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e힙 영역\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e동적인 메모리의 공간을 관리하는 영역\u003c/li\u003e\n\u003cli\u003e힙 영역의 주소값을 스택 영역에 저장하여 변수에 할당할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e데이터 영역\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e데이터 영역은 두가지로 구분된다.\u003c/li\u003e\n\u003cli\u003eBSS : 초기화되지 않은 전역변수\n\u003cul\u003e\n\u003cli\u003e코드 내에서 선언만 했을 경우\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDATA : 초기값이 있는 전역변수\n\u003cul\u003e\n\u003cli\u003e코드 내에서 선언과 함께 초기값을 할당했을 경우\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e컨텍스트 스위칭\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e스케쥴러가 running 상태의 프로세스를 바꿀 때 두 프로세스에서 상태를 변경하는 방법\u003c/li\u003e\n\u003cli\u003eA → B 로 컨텍스트 스위칭이 일어나면 현재 레지스터의 PC와 SP를 \u003ccode\u003ePCB(Process Control Block)\u003c/code\u003e에 저장해서 현재 실행중인 상태를 보관할 수 있음\u003c/li\u003e\n\u003cli\u003eB → A 로 다시 컨텍스트 스위칭이 일어나면 PCB를 확인해서 저장된 PC와 SP를 레지스터에 덮어씌워 이전에 진행하던 상태로 돌아옴\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003ePCB\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e프로세스가 실행중인 상태를 캡쳐/구조화 해서 저장하는 공간\u003c/li\u003e\n\u003cli\u003e프로세스ID, 레지스터 값(PC, SP 등), 스케쥴링 상태 정보, 메모리 정보 등을 저장\u003c/li\u003e\n\u003cli\u003e컨텍스트 스위칭은 매우 자주일어나고 오버헤드등으로 지연될 경우 성능 전체에 영향을 주기 때문에 동작이 어셈블리어로 작성되어 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e프로세스간 커뮤니케이션\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e프로세스간의 공간은 완전히 분리되어 있음\u003c/li\u003e\n\u003cli\u003e다른 프로세스간의 상호 접근하는 방법은 보안상의 이유로 제공되지 않음\u003c/li\u003e\n\u003cli\u003e필요한 경우 프로세스간의 통신을 할 수 있는 IPC(InterProcess Communication)라는 방법을 제공함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003ccode\u003efork()\u003c/code\u003e 시스템 콜\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efork()\u003c/code\u003e 시스템 콜을 통해 하나의 프로세스를 복사하여 새로운 프로세스를 만들 수 있음\u003c/li\u003e\n\u003cli\u003e복사된 프로세스와 통신하기 위해서는 IPC를 사용해야 함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e프로세스간 통신이 필요한 이유\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e하나의 프로그램을 다수의 프로세스를 사용해 구동시켜 효율적으로 프로세서를 사용할 수 있게됨 (멀티코어 프로세스에서 각 코어별로 프로세스를 병렬로 동작)\u003c/li\u003e\n\u003cli\u003e이 때 다른 코어에서 작동하는 프로세스간의 상태 확인 및 데이터 송수신이 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e프로세스 가상메모리의 커널영역\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e각 프로세스는 가상메모리로 4GB씩 할당받는다. 이는 실제 물리메모리에 올라가는 크기가 아니라 프로세스 내에서 활용할 수 있는 공간을 가상으로 할당한 영역이다.\u003c/li\u003e\n\u003cli\u003e이 때 0~3GB는 프로세스가 사용하는 공간 3~4GB는 운영체제 커널이 할당된 공간이다\u003c/li\u003e\n\u003cli\u003e커널 영역은 실제 물리메모리에 올라갈 때 모든 프로세스가 같은 공간을 공유하게 되어있음\u003c/li\u003e\n\u003cli\u003e이 영역을 활용해서 IPC가 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eIPC 기법\u003c/h3\u003e\n\u003ch4\u003e파일을 사용한 커뮤니케이션\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e각 프로세스 별로 처리한 내용을 파일에 저장해서 공유하는 방법\u003c/li\u003e\n\u003cli\u003e실시간으로 원하는 프로세스에 전달하기 어려움\u003c/li\u003e\n\u003cli\u003e저장매체를 사용하기 때문에 효율이 떨어짐\u003c/li\u003e\n\u003cli\u003e커널영역을 사용하지 않는 방법으로 사용성이 매우 떨어짐\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003ePipe\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efork()\u003c/code\u003e를 통해 복사된 프로세스를 향해 단방향으로 데이터를 전달할 수 있음\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epipe()\u003c/code\u003e 시스템 콜에 배열을 전달하면 배열의 1번 인덱스에 작성한 내용을 0번 인덱스에서 읽을 수 있음\n\u003cul\u003e\n\u003cli\u003e단방향 통신이기 때문에 1에서 작성해서 0에서 읽는 건 가능하나, 0에서 작성해서 1로(역방향) 가는 것은 불가능하다\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e메세지 큐 (Message Queue)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e모든 프로세스 사이에서 양방향으로 데이터를 통신할 수 있음\u003c/li\u003e\n\u003cli\u003eFIFO 정책을 기반으로 데이터를 enqueue, dequeue하여 프로세스간 통신한다\u003c/li\u003e\n\u003cli\u003e메세지 큐를 생성하고 해당 큐의 key를 프로세스간에 공유하면 key를 통해 해당 큐에 접근할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e공유 메모리 (Shared Memory)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e커널에 대놓고 메모리 영역을 만들고 해당 영역을 변수처럼 사용하는 방식\u003c/li\u003e\n\u003cli\u003e해당 공유 메모리의 key를 가지고 다수의 프로세스에서 접근할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e시그널 (Signal)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e유닉스에서 30년 이상 사용하고 있는 커널 또는 프로세스에서 다른 프로세스로 이벤트 발생을 알려주는 기법\u003c/li\u003e\n\u003cli\u003e프로세스 관련 코드에 미리 시그널 핸들러를 등록하고 시그널을 받으면 해당 시그널 핸들러를 실행\n\u003cul\u003e\n\u003cli\u003e프로그램에서 특정 시그널에 대한 동작을 임의로 지정해 줄 수 있음\n\u003cul\u003e\n\u003cli\u003e해당 시그널을 무시\u003c/li\u003e\n\u003cli\u003e시그널 블록과 언블록을 통해 지연전달\u003c/li\u003e\n\u003cli\u003e특정 동작을 핸들러로 등록해서 임의로 지정\u003c/li\u003e\n\u003cli\u003e별도로 지정하지 않으면 커널의 기본 동작 수행\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e지정되지 않는 시그널을 받으면 기본적으로 지정된 핸들러가 동작\u003c/li\u003e\n\u003cli\u003e프로세스의 PCB 내부에 해당 프로세스에서 블록된 혹은 처리해야하는 시그널에 관련 정보를 관리함\u003c/li\u003e\n\u003cli\u003e커널모드에서 사용자모드로 전환 할 때 PCB의 대기중인 시그널을 확인해 커널모드를 유지하는 경우도 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e소켓 (Socket)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e서버와 클라이언트 등 두개의 다른 컴퓨터간 네트워크 기반 통신을 위한 기술\u003c/li\u003e\n\u003cli\u003e소켓을 시스템 콜로 사용해 하나의 컴퓨터 안에서 두 개의 프로세스간의 통신 기법으로 활용할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e마무리\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e하나의 코드를 실행하게 되면 다음의 단계를 따라 진행된다.\n\u003col\u003e\n\u003cli\u003e프로세스 생성 후 NEW 상태로 변경\u003c/li\u003e\n\u003cli\u003e메모리에 스택, 힙, 데이터(BBS, DATA), 코드 영역이 할당\u003c/li\u003e\n\u003cli\u003e소스코드 텍스트가 코드 영역에 입력\u003c/li\u003e\n\u003cli\u003e전역 변수를 데이터 영역에 입력\u003c/li\u003e\n\u003cli\u003e프로세의 상태를 READY 상태로 전환\u003c/li\u003e\n\u003cli\u003e스케쥴러에 의해 컨텍스트 스위칭이 일어나 RUNNING 상태로 전환\u003c/li\u003e\n\u003cli\u003e프로세스의 PCB를 불러와서 PC와 SP를 초기화\u003c/li\u003e\n\u003cli\u003e코드의 메인함수를 실행 → SP를 EBP에 저장, 다음 SP에 리턴 주소를 할당\u003c/li\u003e\n\u003cli\u003e함수내의 지역변수를 스택에 입력\u003c/li\u003e\n\u003cli\u003e함수내의 시스템 콜이 일어나게 되면 다음의 단계를 따라 진행된다.\n\u003col\u003e\n\u003cli\u003e시스템 콜의 번호와 시스템 콜의 인자를 EAX, EBX에 저장한 뒤, 0x80 주소로 시스템 콜 인터럽트를 실행\u003c/li\u003e\n\u003cli\u003eCPU의 모드가 커널 모드로 변경\u003c/li\u003e\n\u003cli\u003eIDT에서 0x80에 해당하는 주소의 함수를 찾아서 호출\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esystem_call\u003c/code\u003e함수에서 EAX에 저장된 시스템 콜의 번호를 찾아서, 해당 번호에 맞는 시스템 콜 함수로 이동\u003c/li\u003e\n\u003cli\u003e해당 시스템 콜 함수를 실행한 뒤, 다시 사용자 모드로 변경하고 프로세스의 다음 코드 진행\u003c/li\u003e\n\u003cli\u003e만약 시스템 콜 함수에 대기가 필요하다면 프로세스의 상태를 WAITING으로 변경 한다\u003c/li\u003e\n\u003cli\u003e시스템 콜의 처리가 끝나면 인터럽트를 통해 WAITING된 프로세스를 READY상태로 바꿔준다\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e함수가 종료하게 될 때 반환값이 있다면 프로세스 레지스터의 EAX에 저장한 뒤 스택을 모두 POP한다.\u003c/li\u003e\n\u003cli\u003e리턴 어드레스를 POP하게 되면 해당 주소의 코드를 실행하고 만약 반환값을 사용한다면 EAX에 저장된 값을 사용한다\u003c/li\u003e\n\u003cli\u003e프로세스가 종료하게 되면 프로세스의 상태를 TERMINATED로 변경하고 종료한다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","excerpt":""},"__N_SSG":true},"page":"/[year]/[slug]","query":{"year":"2021","slug":"[CS]-프로세스"},"buildId":"7_nLpp8ghi2rTktMODD63","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>