{"componentChunkName":"component---src-templates-blog-post-js","path":"/[CS]프로세스-상태/","result":{"data":{"site":{"siteMetadata":{"title":"kimjeongwonn"}},"markdownRemark":{"id":"3ab20488-58b0-5710-821d-e8a1a1cbf058","excerpt":"프로세스 스케쥴러의 스케쥴링 알고리즘이 동작하기 위해서는 반드시 프로세스의 상태를 알 수 있어야 한다. 프로세스의 상태는 다음과 같이 정의되어 있다. 프로세스 생성  프로세스를 초기화 하고 있는 상태이므로 ready상태가 되면 실행 가능하다. 실행 가능  CPU…","html":"<ul>\n<li>프로세스 스케쥴러의 스케쥴링 알고리즘이 동작하기 위해서는 반드시 프로세스의 상태를 알 수 있어야 한다.</li>\n<li>프로세스의 상태는 다음과 같이 정의되어 있다.\n<ul>\n<li>프로세스 생성 <code class=\"language-text\">new</code>\n<ul>\n<li>프로세스를 초기화 하고 있는 상태이므로 ready상태가 되면 실행 가능하다.</li>\n</ul>\n</li>\n<li>실행 가능 <code class=\"language-text\">ready</code>\n<ul>\n<li>CPU에서 바로 실행이 가능한 상태</li>\n<li>스케쥴러의 대상이 된다.</li>\n</ul>\n</li>\n<li>실행 중 <code class=\"language-text\">running</code>\n<ul>\n<li>현재 CPU에서 작업중인 프로세스의 상태</li>\n<li>코어별로 최대 1개의 상태를 가질 수 있다.</li>\n<li>스케쥴러가 결정한다.</li>\n</ul>\n</li>\n<li>대기 <code class=\"language-text\">blocked</code>\n<ul>\n<li>특정 이벤트가 발생하기를 대기하는 상태</li>\n<li>예를 들어서 파일 읽기를 저장장치에 요청했다면, 파일 읽기 완료 이벤트가 발생할 때 까지 대기상태로 <code class=\"language-text\">blocked</code>되어 있다가, 이벤트가 발생하면 다시 <code class=\"language-text\">ready</code>가 된다.</li>\n</ul>\n</li>\n<li>종료 <code class=\"language-text\">exit</code>\n<ul>\n<li>프로세스가 사용했떤 자원을 반납하기 위해 처리중인 상태</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>프로세스 상태 기반 스케쥴링</h2>\n<ul>\n<li>스케쥴러는 프로세스의 상태만 보고 스케쥴링을 결정하기는 어렵기 때문에 정책이 필요함</li>\n<li><code class=\"language-text\">ready</code>, <code class=\"language-text\">running</code>, <code class=\"language-text\">blocked</code>상태별로 큐를 만들어서 프로세스를 관리할 수 있음\n<ul>\n<li><code class=\"language-text\">ready</code> 큐에 있는 프로세스를 계속 <code class=\"language-text\">dequeue</code>하여 처리하는 것을 반복 <code class=\"language-text\">running</code>큐에 <code class=\"language-text\">enqueue</code></li>\n<li>프로세스가 대기(blocked)하게 된다면 그 동안 <code class=\"language-text\">blocked</code>큐에 넣어 <code class=\"language-text\">ready</code>큐에 들어가지 않음</li>\n</ul>\n</li>\n<li>이 과정의 반복을 통해 효율적으로 실행 가능한 프로세스를 처리하여 멀티 프로그래밍이 가능</li>\n</ul>\n<h3>선점형 스케쥴러</h3>\n<ul>\n<li>하나의 프로세스가 CPU에서 running 상태로 동작하고 있는 중에 다른 프로세스가 선점하여 처리할 수 있음</li>\n<li>시분할 시스템 구현 가능</li>\n<li>RoundRobin 스케쥴러</li>\n</ul>\n<h3>비선점형 스케쥴러</h3>\n<ul>\n<li>하나의 프로세스가 end 상태가 되거나 blocked 상태가 될 때 까지 다른 프로세스가 선점하여 처리할 수 없음</li>\n<li>FCFS, SJF, Priority-based 스케쥴러</li>\n</ul>\n<h3>스케쥴링 알고리즘 조합</h3>\n<ul>\n<li>운영체제는 다양한 스케쥴링 알고리즘을 조합한 스케쥴러로 동작한다.</li>\n<li>예) RoundRobin + Priority-based\n<ul>\n<li>우선순위를 갖는 시분할 스케쥴러</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[CS] 프로세스 - 상태","date":"2021-08-18T12:09:23.000Z","description":null}},"previous":{"fields":{"slug":"/[CS]프로세스-스케쥴러/"},"frontmatter":{"title":"[CS] 프로세스 - 스케쥴러"}},"next":null},"pageContext":{"id":"3ab20488-58b0-5710-821d-e8a1a1cbf058","previousPostId":"2a1e993a-e906-5daa-b948-a89972a6d165","nextPostId":null}},"staticQueryHashes":["2841359383"]}