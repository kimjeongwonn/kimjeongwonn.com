{"componentChunkName":"component---src-templates-blog-post-js","path":"/[CS]프로세스/","result":{"data":{"site":{"siteMetadata":{"title":"kimjeongwonn"}},"markdownRemark":{"id":"c262d8a5-6d2a-5873-89aa-1e61ea4f13a7","excerpt":"스케쥴러 배치 처리 시스템 시스템이 여러개의 프로그램을 순차적으로 처리하는 방식 Queue 자료구조와 비슷한 방식으로 동작 하나의 프로그램이 실행되는 동안 다른 작업을 하지 못함 → 한 번에 하나의 프로그램 처리만 가능 멀티 태스킹 단일 CPU…","html":"<h2>스케쥴러</h2>\n<h3>배치 처리 시스템</h3>\n<ul>\n<li>시스템이 여러개의 프로그램을 순차적으로 처리하는 방식\n<ul>\n<li>Queue 자료구조와 비슷한 방식으로 동작</li>\n</ul>\n</li>\n<li>하나의 프로그램이 실행되는 동안 다른 작업을 하지 못함 → 한 번에 하나의 프로그램 처리만 가능</li>\n</ul>\n<h3>멀티 태스킹</h3>\n<ul>\n<li>단일 CPU에서 다수의 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 방법</li>\n</ul>\n<h4>시 분할 시스템</h4>\n<ul>\n<li>시간단위로 아주 잘게 분할해서 여러가지 프로그램을 번갈아가면서 처리하는 방식</li>\n<li>다중 사용자가 시스템을 사용할 수 있으며, 입력에 대한 응답시간을 최소화 할 수 있음</li>\n</ul>\n<h4>멀티 태스킹과 멀티 프로세싱</h4>\n<ul>\n<li>멀티 태스킹은 단일 CPU가 시분할 시스템을 이용해 동시에 여러가지 프로그램을 처리하는 것</li>\n<li>멀티 프로세싱은 다중 CPU가 하나의 프로그램을 병렬로 처리하는 것</li>\n</ul>\n<h4>멀티 프로그래밍</h4>\n<ul>\n<li>응용 프로그램은 CPU만 사용하는 것이 아니라, 다른 작업을 중간에 필요로 하는 경우가 많음\n<ul>\n<li>예) 저장 매체 사용, 입력 장치, 출력 장치 사용 등</li>\n</ul>\n</li>\n<li>하나의 응용프로그램이 CPU 외의 장치를 사용하면서 CPU를 사용하지 않으면서 점유할 때 다른 프로그램에서 CPU를 사용할 수 있도록 해서 CPU가 낭비되는 시간이 없도록 한다.</li>\n<li>CPU를 최대한 효율적으로 활용하도록 하는 시스템</li>\n</ul>\n<h3>프로세스</h3>\n<ul>\n<li>실행중인 프로그램의 실행단위 → 메모리 위에 올라가 있는 프로그램\n<ul>\n<li>코드 이미지(바이너리): 실행 파일</li>\n</ul>\n</li>\n<li><code class=\"language-text\">작업</code>, <code class=\"language-text\">Task</code>, <code class=\"language-text\">Job</code> 등 용어를 혼용하여 사용한다.</li>\n<li>응용 프로그램 ≠ 프로세스\n<ul>\n<li>응용 프로그램은 여러개의 프로세스로 이루어질 수 있음</li>\n<li>하나의 응용 프로그램이 기능을 처리하기 위해 다수의 프로세스가 상호작용하여 실행될 수 있음</li>\n</ul>\n</li>\n</ul>\n<h3>스케쥴러</h3>\n<ul>\n<li>스케쥴러는 프로세스의 실행을 단위별로 관리한다.</li>\n</ul>\n<h4>스케쥴링 알고리즘</h4>\n<ul>\n<li>프로세스를 실행시키는 순서와 방법을 결정하는 알고리즘</li>\n<li>시 분할 시스템을 구현 → 프로세스 응답 시간을 최대한 짧게</li>\n<li>멀티 프로그래밍을 구현 → CPU의 활용도를 최대한 높여서 효율적으로</li>\n</ul>\n<h4>FIFO 스케쥴러</h4>\n<ul>\n<li>프로세스를 처음부터 끝까지 순차적으로 처리하는 가장 간단한 스케줄러</li>\n<li>배치 처리 시스템과 가장 유사</li>\n<li>FCFS(First Come First Served) 스케쥴러라고 부르기도 함</li>\n</ul>\n<h4>SFJ 스케쥴러</h4>\n<ul>\n<li>Shortest Job First 스케쥴러 → 최단 작업 우선</li>\n<li>프로세스의 작업 시간을 알고 있을 때 가장 빠른 프로세스를 먼저 처리하는 스케줄러</li>\n<li>장점\n<ul>\n<li>FIFO 스케쥴러 보다 응답시간이 짧을 수 있음</li>\n<li>같은 시간 내에 더 많은 프로세스를 처리할 수 있음</li>\n</ul>\n</li>\n<li>단점\n<ul>\n<li>프로세스의 작업 시간을 미리 모두 알아야 함</li>\n<li>작업 시간이 오래 걸리는 프로세스는 계속해서 우선순위가 뒤로 밀리게 됨</li>\n</ul>\n</li>\n</ul>\n<h4>우선순위 기반 스케쥴러</h4>\n<ul>\n<li>Priority-Based 스케쥴러</li>\n<li>우선순위를 정하는 기준은 정적 우선순위, 동적 우선순위가 있다</li>\n<li>정적 우선순위\n<ul>\n<li>프로세스마다 우선순위를 미리 지정한다</li>\n</ul>\n</li>\n<li>동적 우선순위\n<ul>\n<li>스케쥴러가 상황에 따라 우선순위를 동적으로 변경한다</li>\n<li>시스템이 목표하는 기준에 맞춰 이전에 처리한 내용을 기반으로 우선순위를 결정한다.</li>\n</ul>\n</li>\n</ul>\n<h4>Round Robin 스케쥴러</h4>\n<ul>\n<li>시 분할 시스템을 기반으로 동작하는 스케쥴러</li>\n<li>대기 큐에 있는 프로세스를 FCFS 방식으로 처리한다.</li>\n<li>지정된 시간 내에 프로세스가 모두 처리가 되지 않으면 다시 대기 큐에 넣는다.</li>\n</ul>\n<h2>상태</h2>\n<ul>\n<li>프로세스 스케쥴러의 스케쥴링 알고리즘이 동작하기 위해서는 반드시 프로세스의 상태를 알 수 있어야 한다.</li>\n<li>프로세스의 상태는 다음과 같이 정의되어 있다.\n<ul>\n<li>프로세스 생성 <code class=\"language-text\">new</code>\n<ul>\n<li>프로세스를 초기화 하고 있는 상태이므로 ready상태가 되면 실행 가능하다.</li>\n</ul>\n</li>\n<li>실행 가능 <code class=\"language-text\">ready</code>\n<ul>\n<li>CPU에서 바로 실행이 가능한 상태</li>\n<li>스케쥴러의 대상이 된다.</li>\n</ul>\n</li>\n<li>실행 중 <code class=\"language-text\">running</code>\n<ul>\n<li>현재 CPU에서 작업중인 프로세스의 상태</li>\n<li>코어별로 최대 1개의 상태를 가질 수 있다.</li>\n<li>스케쥴러가 결정한다.</li>\n</ul>\n</li>\n<li>대기 <code class=\"language-text\">blocked</code>\n<ul>\n<li>특정 이벤트가 발생하기를 대기하는 상태</li>\n<li>예를 들어서 파일 읽기를 저장장치에 요청했다면, 파일 읽기 완료 이벤트가 발생할 때 까지 대기상태로 <code class=\"language-text\">blocked</code>되어 있다가, 이벤트가 발생하면 다시 <code class=\"language-text\">ready</code>가 된다.</li>\n</ul>\n</li>\n<li>종료 <code class=\"language-text\">exit</code>\n<ul>\n<li>프로세스가 사용했떤 자원을 반납하기 위해 처리중인 상태</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>프로세스 상태 기반 스케쥴링</h3>\n<ul>\n<li>스케쥴러는 프로세스의 상태만 보고 스케쥴링을 결정하기는 어렵기 때문에 정책이 필요함</li>\n<li><code class=\"language-text\">ready</code>, <code class=\"language-text\">running</code>, <code class=\"language-text\">blocked</code>상태별로 큐를 만들어서 프로세스를 관리할 수 있음\n<ul>\n<li><code class=\"language-text\">ready</code> 큐에 있는 프로세스를 계속 <code class=\"language-text\">dequeue</code>하여 처리하는 것을 반복 <code class=\"language-text\">running</code>큐에 <code class=\"language-text\">enqueue</code></li>\n<li>프로세스가 대기(blocked)하게 된다면 그 동안 <code class=\"language-text\">blocked</code>큐에 넣어 <code class=\"language-text\">ready</code>큐에 들어가지 않음</li>\n</ul>\n</li>\n<li>이 과정의 반복을 통해 효율적으로 실행 가능한 프로세스를 처리하여 멀티 프로그래밍이 가능</li>\n</ul>\n<h4>선점형 스케쥴러</h4>\n<ul>\n<li>하나의 프로세스가 CPU에서 running 상태로 동작하고 있는 중에 다른 프로세스가 선점하여 처리할 수 있음</li>\n<li>시분할 시스템 구현 가능</li>\n<li>RoundRobin 스케쥴러</li>\n</ul>\n<h4>비선점형 스케쥴러</h4>\n<ul>\n<li>하나의 프로세스가 end 상태가 되거나 blocked 상태가 될 때 까지 다른 프로세스가 선점하여 처리할 수 없음</li>\n<li>FCFS, SJF, Priority-based 스케쥴러</li>\n</ul>\n<h4>스케쥴링 알고리즘 조합</h4>\n<ul>\n<li>운영체제는 다양한 스케쥴링 알고리즘을 조합한 스케쥴러로 동작한다.</li>\n<li>예) RoundRobin + Priority-based\n<ul>\n<li>우선순위를 갖는 시분할 스케쥴러</li>\n</ul>\n</li>\n</ul>\n<h2>인터럽트</h2>\n<ul>\n<li>CPU가 작업을 처리중인 상황에 하드웨어나 소프트웨어의 이벤트 발생, 예외상황 발생 처리를 위해 CPU에 알려주는 기술</li>\n<li>일종의 이벤트로 볼 수 있음</li>\n</ul>\n<h3>인터럽트가 필요한 이유</h3>\n<ul>\n<li>선점형 스케쥴러의 구현을 위해서는 running 상태의 프로세스를 중단시키고 다른 프로세스로 교체해야 함\n<ul>\n<li>이를 위해 스케쥴러 코드가 인터럽트를 통해 현재 실행중인 프로세스를 중단 시켜야 함</li>\n</ul>\n</li>\n<li>입출력 장치의 처리 혹은 예외상황(0으로 나누기 등)이 발생했을 때 CPU에서 해당 상황에 대한 처리를 위해 인터럽트를 통해 알릴 수 있음</li>\n</ul>\n<h3>인터럽트의 종류</h3>\n<h4>내부 인터럽트 (소프트웨어 인터럽트)</h4>\n<ol>\n<li>Divide-by-Zero 인터럽트 : 0으로 나누는 명령 실행 시 발생하는 인터럽트</li>\n</ol>\n<ul>\n<li>사용자 모드에서 잘못된 공간 접근 시\n<ul>\n<li>프로세스는 4GB의 메모리를 사용할 수 있는데 사용자 모드에서는 0GB<del>3GB, 커널모드에서는 3GB</del>4GB에 접근할 수 있음</li>\n</ul>\n</li>\n<li>계산 결과에서 Overflow 혹은 Underflow가 발생할 때</li>\n</ul>\n<h4>외부 인터럽트 (하드웨어 인터럽트)</h4>\n<ol>\n<li>타이머 인터럽트 : 선점형 스케쥴러를 구현하기 위해 일정 시간마다 인터럽트를 계속 발생시켜 현재 처리해야 하는 프로세스를 결정할 수 있음</li>\n<li>입출력 인터럽트 : 입출력 장치(키보드, 마우스, 저장매체, 프린터 등)에서 작업을 처리하고 완료됐음을 알려서 후속 처리를 할 수 있음</li>\n</ol>\n<h3>인터럽트 동작</h3>\n<h4>시스템 콜 인터럽트</h4>\n<ul>\n<li>시스템 콜을 실행하기 위해 인터럽트 명령을 넣어 실행시켜야 한다. → 커널 모드로 전환을 위해\n<ul>\n<li>eax 레지스터에 시스템 콜 번호를, ebx 레지스터에 인자값을 넣고 소프트웨어 인터럽트를 호출하면서 시스템콜에 해당하는 0x80값을 넘겨서 호출</li>\n<li>CPU가 커널모드로 IDT에서 0x80에 해당하는 함수(시스템 콜)를 실행</li>\n<li>시스템 콜 함수가 eax 레지스터에 저장된 시스템 콜 번호를 통해 원하는 시스템 콜 호출</li>\n<li>함수 실행 후, 다시 사용자 모드로 변경하고 다시 해당 프로세스 다음코드 실행</li>\n</ul>\n</li>\n</ul>\n<h4>IDT</h4>\n<ul>\n<li>인터럽트는 미리 정의되어 있는 실행코드의 주소를 IDT에 저장하고 있음</li>\n<li>컴퓨터 부팅 시 운영체제가 커널 영역에 IDT영역을 초기화하고 정의함</li>\n<li>리눅스 기준으로 아래와 같이 구분되어 있음\n<ul>\n<li>0 ~ 31 : 예외상황 인터럽트</li>\n<li>32 ~ 47 : 하드웨어 인터럽트</li>\n<li>128(<code class=\"language-text\">0x80</code>) : 시스템 콜</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[CS] 프로세스","date":"2021-08-17T08:29:30.000Z","description":null}},"previous":{"fields":{"slug":"/[CS]운영체제/"},"frontmatter":{"title":"[CS] 운영체제"}},"next":null},"pageContext":{"id":"c262d8a5-6d2a-5873-89aa-1e61ea4f13a7","previousPostId":"2f74154c-f748-5eff-8c8f-01cc80085c72","nextPostId":null}},"staticQueryHashes":["2841359383"]}