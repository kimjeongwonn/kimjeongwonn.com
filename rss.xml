<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[kimjeongwonn]]></title><description><![CDATA[김정원의 프론트엔드 기술블로그]]></description><link>https://kimjeongwonn.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 24 Aug 2021 10:17:46 GMT</lastBuildDate><item><title><![CDATA[[CS] 프로세스]]></title><description><![CDATA[계속 추가중 스케쥴러 배치 처리 시스템 시스템이 여러개의 프로그램을 순차적으로 처리하는 방식 Queue…]]></description><link>https://kimjeongwonn.github.io/[CS]프로세스/</link><guid isPermaLink="false">https://kimjeongwonn.github.io/[CS]프로세스/</guid><pubDate>Tue, 17 Aug 2021 08:29:30 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;계속 추가중&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;스케쥴러&lt;/h2&gt;
&lt;h3&gt;배치 처리 시스템&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템이 여러개의 프로그램을 순차적으로 처리하는 방식
&lt;ul&gt;
&lt;li&gt;Queue 자료구조와 비슷한 방식으로 동작&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;하나의 프로그램이 실행되는 동안 다른 작업을 하지 못함 → 한 번에 하나의 프로그램 처리만 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;멀티 태스킹&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단일 CPU에서 다수의 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 방법&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;시 분할 시스템&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;시간단위로 아주 잘게 분할해서 여러가지 프로그램을 번갈아가면서 처리하는 방식&lt;/li&gt;
&lt;li&gt;다중 사용자가 시스템을 사용할 수 있으며, 입력에 대한 응답시간을 최소화 할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;멀티 태스킹과 멀티 프로세싱&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;멀티 태스킹은 단일 CPU가 시분할 시스템을 이용해 동시에 여러가지 프로그램을 처리하는 것&lt;/li&gt;
&lt;li&gt;멀티 프로세싱은 다중 CPU가 하나의 프로그램을 병렬로 처리하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;멀티 프로그래밍&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;응용 프로그램은 CPU만 사용하는 것이 아니라, 다른 작업을 중간에 필요로 하는 경우가 많음
&lt;ul&gt;
&lt;li&gt;예) 저장 매체 사용, 입력 장치, 출력 장치 사용 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;하나의 응용프로그램이 CPU 외의 장치를 사용하면서 CPU를 사용하지 않으면서 점유할 때 다른 프로그램에서 CPU를 사용할 수 있도록 해서 CPU가 낭비되는 시간이 없도록 한다.&lt;/li&gt;
&lt;li&gt;CPU를 최대한 효율적으로 활용하도록 하는 시스템&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;프로세스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;실행중인 프로그램의 실행단위 → 메모리 위에 올라가 있는 프로그램
&lt;ul&gt;
&lt;li&gt;코드 이미지(바이너리): 실행 파일&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;작업&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Task&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Job&lt;/code&gt; 등 용어를 혼용하여 사용한다.&lt;/li&gt;
&lt;li&gt;응용 프로그램 ≠ 프로세스
&lt;ul&gt;
&lt;li&gt;응용 프로그램은 여러개의 프로세스로 이루어질 수 있음&lt;/li&gt;
&lt;li&gt;하나의 응용 프로그램이 기능을 처리하기 위해 다수의 프로세스가 상호작용하여 실행될 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;스케쥴러&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;스케쥴러는 프로세스의 실행을 단위별로 관리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;스케쥴링 알고리즘&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;프로세스를 실행시키는 순서와 방법을 결정하는 알고리즘&lt;/li&gt;
&lt;li&gt;시 분할 시스템을 구현 → 프로세스 응답 시간을 최대한 짧게&lt;/li&gt;
&lt;li&gt;멀티 프로그래밍을 구현 → CPU의 활용도를 최대한 높여서 효율적으로&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;FIFO 스케쥴러&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;프로세스를 처음부터 끝까지 순차적으로 처리하는 가장 간단한 스케줄러&lt;/li&gt;
&lt;li&gt;배치 처리 시스템과 가장 유사&lt;/li&gt;
&lt;li&gt;FCFS(First Come First Served) 스케쥴러라고 부르기도 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;SFJ 스케쥴러&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Shortest Job First 스케쥴러 → 최단 작업 우선&lt;/li&gt;
&lt;li&gt;프로세스의 작업 시간을 알고 있을 때 가장 빠른 프로세스를 먼저 처리하는 스케줄러&lt;/li&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;FIFO 스케쥴러 보다 응답시간이 짧을 수 있음&lt;/li&gt;
&lt;li&gt;같은 시간 내에 더 많은 프로세스를 처리할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;프로세스의 작업 시간을 미리 모두 알아야 함&lt;/li&gt;
&lt;li&gt;작업 시간이 오래 걸리는 프로세스는 계속해서 우선순위가 뒤로 밀리게 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;우선순위 기반 스케쥴러&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Priority-Based 스케쥴러&lt;/li&gt;
&lt;li&gt;우선순위를 정하는 기준은 정적 우선순위, 동적 우선순위가 있다&lt;/li&gt;
&lt;li&gt;정적 우선순위
&lt;ul&gt;
&lt;li&gt;프로세스마다 우선순위를 미리 지정한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;동적 우선순위
&lt;ul&gt;
&lt;li&gt;스케쥴러가 상황에 따라 우선순위를 동적으로 변경한다&lt;/li&gt;
&lt;li&gt;시스템이 목표하는 기준에 맞춰 이전에 처리한 내용을 기반으로 우선순위를 결정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Round Robin 스케쥴러&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;시 분할 시스템을 기반으로 동작하는 스케쥴러&lt;/li&gt;
&lt;li&gt;대기 큐에 있는 프로세스를 FCFS 방식으로 처리한다.&lt;/li&gt;
&lt;li&gt;지정된 시간 내에 프로세스가 모두 처리가 되지 않으면 다시 대기 큐에 넣는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;상태&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로세스 스케쥴러의 스케쥴링 알고리즘이 동작하기 위해서는 반드시 프로세스의 상태를 알 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;프로세스의 상태는 다음과 같이 정의되어 있다.
&lt;ul&gt;
&lt;li&gt;프로세스 생성 &lt;code class=&quot;language-text&quot;&gt;new&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;프로세스를 초기화 하고 있는 상태이므로 ready상태가 되면 실행 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;실행 가능 &lt;code class=&quot;language-text&quot;&gt;ready&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;CPU에서 바로 실행이 가능한 상태&lt;/li&gt;
&lt;li&gt;스케쥴러의 대상이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;실행 중 &lt;code class=&quot;language-text&quot;&gt;running&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;현재 CPU에서 작업중인 프로세스의 상태&lt;/li&gt;
&lt;li&gt;코어별로 최대 1개의 상태를 가질 수 있다.&lt;/li&gt;
&lt;li&gt;스케쥴러가 결정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;대기 &lt;code class=&quot;language-text&quot;&gt;blocked&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;특정 이벤트가 발생하기를 대기하는 상태&lt;/li&gt;
&lt;li&gt;예를 들어서 파일 읽기를 저장장치에 요청했다면, 파일 읽기 완료 이벤트가 발생할 때 까지 대기상태로 &lt;code class=&quot;language-text&quot;&gt;blocked&lt;/code&gt;되어 있다가, 이벤트가 발생하면 다시 &lt;code class=&quot;language-text&quot;&gt;ready&lt;/code&gt;가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;종료 &lt;code class=&quot;language-text&quot;&gt;exit&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;프로세스가 사용했떤 자원을 반납하기 위해 처리중인 상태&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;프로세스 상태 기반 스케쥴링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;스케쥴러는 프로세스의 상태만 보고 스케쥴링을 결정하기는 어렵기 때문에 정책이 필요함&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ready&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;running&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;blocked&lt;/code&gt;상태별로 큐를 만들어서 프로세스를 관리할 수 있음
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ready&lt;/code&gt; 큐에 있는 프로세스를 계속 &lt;code class=&quot;language-text&quot;&gt;dequeue&lt;/code&gt;하여 처리하는 것을 반복 &lt;code class=&quot;language-text&quot;&gt;running&lt;/code&gt;큐에 &lt;code class=&quot;language-text&quot;&gt;enqueue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;프로세스가 대기(blocked)하게 된다면 그 동안 &lt;code class=&quot;language-text&quot;&gt;blocked&lt;/code&gt;큐에 넣어 &lt;code class=&quot;language-text&quot;&gt;ready&lt;/code&gt;큐에 들어가지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이 과정의 반복을 통해 효율적으로 실행 가능한 프로세스를 처리하여 멀티 프로그래밍이 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;선점형 스케쥴러&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;하나의 프로세스가 CPU에서 running 상태로 동작하고 있는 중에 다른 프로세스가 선점하여 처리할 수 있음&lt;/li&gt;
&lt;li&gt;시분할 시스템 구현 가능&lt;/li&gt;
&lt;li&gt;RoundRobin 스케쥴러&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;비선점형 스케쥴러&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;하나의 프로세스가 end 상태가 되거나 blocked 상태가 될 때 까지 다른 프로세스가 선점하여 처리할 수 없음&lt;/li&gt;
&lt;li&gt;FCFS, SJF, Priority-based 스케쥴러&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;스케쥴링 알고리즘 조합&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;운영체제는 다양한 스케쥴링 알고리즘을 조합한 스케쥴러로 동작한다.&lt;/li&gt;
&lt;li&gt;예) RoundRobin + Priority-based
&lt;ul&gt;
&lt;li&gt;우선순위를 갖는 시분할 스케쥴러&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;인터럽트&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CPU가 작업을 처리중인 상황에 하드웨어나 소프트웨어의 이벤트 발생, 예외상황 발생 처리를 위해 CPU에 알려주는 기술&lt;/li&gt;
&lt;li&gt;일종의 이벤트로 볼 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;인터럽트가 필요한 이유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;선점형 스케쥴러의 구현을 위해서는 running 상태의 프로세스를 중단시키고 다른 프로세스로 교체해야 함
&lt;ul&gt;
&lt;li&gt;이를 위해 스케쥴러 코드가 인터럽트를 통해 현재 실행중인 프로세스를 중단 시켜야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;입출력 장치의 처리 혹은 예외상황(0으로 나누기 등)이 발생했을 때 CPU에서 해당 상황에 대한 처리를 위해 인터럽트를 통해 알릴 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;인터럽트의 종류&lt;/h3&gt;
&lt;h4&gt;내부 인터럽트 (소프트웨어 인터럽트)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Divide-by-Zero 인터럽트 : 0으로 나누는 명령 실행 시 발생하는 인터럽트&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;사용자 모드에서 잘못된 공간 접근 시
&lt;ul&gt;
&lt;li&gt;프로세스는 4GB의 메모리를 사용할 수 있는데 사용자 모드에서는 0GB&lt;del&gt;3GB, 커널모드에서는 3GB&lt;/del&gt;4GB에 접근할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;계산 결과에서 Overflow 혹은 Underflow가 발생할 때&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;외부 인터럽트 (하드웨어 인터럽트)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;타이머 인터럽트 : 선점형 스케쥴러를 구현하기 위해 일정 시간마다 인터럽트를 계속 발생시켜 현재 처리해야 하는 프로세스를 결정할 수 있음&lt;/li&gt;
&lt;li&gt;입출력 인터럽트 : 입출력 장치(키보드, 마우스, 저장매체, 프린터 등)에서 작업을 처리하고 완료됐음을 알려서 후속 처리를 할 수 있음&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;인터럽트 동작&lt;/h3&gt;
&lt;h4&gt;시스템 콜 인터럽트&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;시스템 콜을 실행하기 위해 인터럽트 명령을 넣어 실행시켜야 한다. → 커널 모드로 전환을 위해
&lt;ul&gt;
&lt;li&gt;eax 레지스터에 시스템 콜 번호를, ebx 레지스터에 인자값을 넣고 소프트웨어 인터럽트를 호출하면서 시스템콜에 해당하는 0x80값을 넘겨서 호출&lt;/li&gt;
&lt;li&gt;CPU가 커널모드로 IDT에서 0x80에 해당하는 함수(시스템 콜)를 실행&lt;/li&gt;
&lt;li&gt;시스템 콜 함수가 eax 레지스터에 저장된 시스템 콜 번호를 통해 원하는 시스템 콜 호출&lt;/li&gt;
&lt;li&gt;함수 실행 후, 다시 사용자 모드로 변경하고 다시 해당 프로세스 다음코드 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;IDT&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;인터럽트는 미리 정의되어 있는 실행코드의 주소를 IDT에 저장하고 있음&lt;/li&gt;
&lt;li&gt;컴퓨터 부팅 시 운영체제가 커널 영역에 IDT영역을 초기화하고 정의함&lt;/li&gt;
&lt;li&gt;리눅스 기준으로 아래와 같이 구분되어 있음
&lt;ul&gt;
&lt;li&gt;0 ~ 31 : 예외상황 인터럽트&lt;/li&gt;
&lt;li&gt;32 ~ 47 : 하드웨어 인터럽트&lt;/li&gt;
&lt;li&gt;128(&lt;code class=&quot;language-text&quot;&gt;0x80&lt;/code&gt;) : 시스템 콜&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;컨텍스트 스위칭&lt;/h2&gt;
&lt;h3&gt;프로세스의 구조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드가 컴파일 되면서 기계어로 전환되어 실행파일로 만들어 진다.&lt;/li&gt;
&lt;li&gt;실행 파일을 실행하면 프로세스가 생성되고 프로세스 내부에 코드 영역에 기계어로 변환 된 코드가 올라간다.&lt;/li&gt;
&lt;li&gt;코드 영역의 코드를 실행하고 코드 내부에서 전역으로 선언 된 변수는 데이터 영역에 저장된다&lt;/li&gt;
&lt;li&gt;함수가 실행되고 내부에서 선언된 매개변수, 변수는 함수 반환 시 메모리 함께 사라지기 때문에 스택 영역에 저장된다.
&lt;ul&gt;
&lt;li&gt;함수가 실행 될 때 함수가 반환되고 이동할 Return Address를 먼저 Push한다.&lt;/li&gt;
&lt;li&gt;차례대로 매개변수와 변수를 Push한다.&lt;/li&gt;
&lt;li&gt;함수가 종료되면 차례대로 Pop하고 마지막에 Return Address가 Pop되면 해당 주소로 이동한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;프로세스 내에서 동적인 데이터를 담는 메모리 공간이 필요할 때 힙 영역에 저장된다.&lt;/li&gt;
&lt;li&gt;코드 영역과 데이터 영역은 프로세스 생성시 정적으로 결정된다.&lt;/li&gt;
&lt;li&gt;스택 영역은 프로세스 메모리주소의 최대값 부터 힙 영역은 코드영역 다음부터 정의되며 동적으로 할당된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;프로세스 레지스터&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;PC(Program counter) : 코드가 실행되는 주소값을 저장하는 레지스터&lt;/li&gt;
&lt;li&gt;SP(Stack Pointer) : 현재 스택의 Top주소를 저장하는 레지스터&lt;/li&gt;
&lt;li&gt;EBP : 함수가 호출되면 EBP에서 함수가 시작되는 부분을 기록해서 예외가 발생했을 때 예외가 발생한 함수를 특정할 수 있게 해 주는 레지스터&lt;/li&gt;
&lt;li&gt;EAX : 함수의 반환값을 저장하는 레지스터&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;힙 영역&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;동적인 메모리의 공간을 관리하는 영역&lt;/li&gt;
&lt;li&gt;힙 영역의 주소값을 스택 영역에 저장하여 변수에 할당할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;데이터 영역&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터 영역은 두가지로 구분된다.&lt;/li&gt;
&lt;li&gt;BSS : 초기화되지 않은 전역변수
&lt;ul&gt;
&lt;li&gt;코드 내에서 선언만 했을 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DATA : 초기값이 있는 전역변수
&lt;ul&gt;
&lt;li&gt;코드 내에서 선언과 함께 초기값을 할당했을 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;컨텍스트 스위칭&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;스케쥴러가 running 상태의 프로세스를 바꿀 때 두 프로세스에서 상태를 변경하는 방법&lt;/li&gt;
&lt;li&gt;A → B 로 컨텍스트 스위칭이 일어나면 현재 레지스터의 PC와 SP를 &lt;code class=&quot;language-text&quot;&gt;PCB(Process Control Block)&lt;/code&gt;에 저장해서 현재 실행중인 상태를 보관할 수 있음&lt;/li&gt;
&lt;li&gt;B → A 로 다시 컨텍스트 스위칭이 일어나면 PCB를 확인해서 저장된 PC와 SP를 레지스터에 덮어씌워 이전에 진행하던 상태로 돌아옴&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;PCB&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;프로세스가 실행중인 상태를 캡쳐/구조화 해서 저장하는 공간&lt;/li&gt;
&lt;li&gt;프로세스ID, 레지스터 값(PC, SP 등), 스케쥴링 상태 정보, 메모리 정보 등을 저장&lt;/li&gt;
&lt;li&gt;컨텍스트 스위칭은 매우 자주일어나고 오버헤드등으로 지연될 경우 성능 전체에 영향을 주기 때문에 동작이 어셈블리어로 작성되어 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;프로세스간 커뮤니케이션&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로세스간의 공간은 완전히 분리되어 있음&lt;/li&gt;
&lt;li&gt;다른 프로세스간의 상호 접근하는 방법은 보안상의 이유로 제공되지 않음&lt;/li&gt;
&lt;li&gt;필요한 경우 프로세스간의 통신을 할 수 있는 IPC(InterProcess Communication)라는 방법을 제공함&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;fork()&lt;/code&gt; 시스템 콜&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;fork()&lt;/code&gt; 시스템 콜을 통해 하나의 프로세스를 복사하여 새로운 프로세스를 만들 수 있음&lt;/li&gt;
&lt;li&gt;복사된 프로세스와 통신하기 위해서는 IPC를 사용해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;프로세스간 통신이 필요한 이유&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;하나의 프로그램을 다수의 프로세스를 사용해 구동시켜 효율적으로 프로세서를 사용할 수 있게됨 (멀티코어 프로세스에서 각 코어별로 프로세스를 병렬로 동작)&lt;/li&gt;
&lt;li&gt;이 때 다른 코어에서 작동하는 프로세스간의 상태 확인 및 데이터 송수신이 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;프로세스 가상메모리의 커널영역&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;각 프로세스는 가상메모리로 4GB씩 할당받는다. 이는 실제 물리메모리에 올라가는 크기가 아니라 프로세스 내에서 활용할 수 있는 공간을 가상으로 할당한 영역이다.&lt;/li&gt;
&lt;li&gt;이 때 0~3GB는 프로세스가 사용하는 공간 3~4GB는 운영체제 커널이 할당된 공간이다&lt;/li&gt;
&lt;li&gt;커널 영역은 실제 물리메모리에 올라갈 때 모든 프로세스가 같은 공간을 공유하게 되어있음&lt;/li&gt;
&lt;li&gt;이 영역을 활용해서 IPC가 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;IPC 기법&lt;/h3&gt;
&lt;h4&gt;파일을 사용한 커뮤니케이션&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;각 프로세스 별로 처리한 내용을 파일에 저장해서 공유하는 방법&lt;/li&gt;
&lt;li&gt;실시간으로 원하는 프로세스에 전달하기 어려움&lt;/li&gt;
&lt;li&gt;저장매체를 사용하기 때문에 효율이 떨어짐&lt;/li&gt;
&lt;li&gt;커널영역을 사용하지 않는 방법으로 사용성이 매우 떨어짐&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Pipe&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;fork()&lt;/code&gt;를 통해 복사된 프로세스를 향해 단방향으로 데이터를 전달할 수 있음&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;pipe()&lt;/code&gt; 시스템 콜에 배열을 전달하면 배열의 1번 인덱스에 작성한 내용을 0번 인덱스에서 읽을 수 있음
&lt;ul&gt;
&lt;li&gt;단방향 통신이기 때문에 1에서 작성해서 0에서 읽는 건 가능하나, 0에서 작성해서 1로(역방향) 가는 것은 불가능하다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;메세지 큐 (Message Queue)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;모든 프로세스 사이에서 양방향으로 데이터를 통신할 수 있음&lt;/li&gt;
&lt;li&gt;FIFO 정책을 기반으로 데이터를 enqueue, dequeue하여 프로세스간 통신한다&lt;/li&gt;
&lt;li&gt;메세지 큐를 생성하고 해당 큐의 key를 프로세스간에 공유하면 key를 통해 해당 큐에 접근할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;공유 메모리 (Shared Memory)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;커널에 대놓고 메모리 영역을 만들고 해당 영역을 변수처럼 사용하는 방식&lt;/li&gt;
&lt;li&gt;해당 공유 메모리의 key를 가지고 다수의 프로세스에서 접근할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;시그널 (Signal)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;유닉스에서 30년 이상 사용하고 있는 커널 또는 프로세스에서 다른 프로세스로 이벤트 발생을 알려주는 기법&lt;/li&gt;
&lt;li&gt;프로세스 관련 코드에 미리 시그널 핸들러를 등록하고 시그널을 받으면 해당 시그널 핸들러를 실행
&lt;ul&gt;
&lt;li&gt;프로그램에서 특정 시그널에 대한 동작을 임의로 지정해 줄 수 있음
&lt;ul&gt;
&lt;li&gt;해당 시그널을 무시&lt;/li&gt;
&lt;li&gt;시그널 블록과 언블록을 통해 지연전달&lt;/li&gt;
&lt;li&gt;특정 동작을 핸들러로 등록해서 임의로 지정&lt;/li&gt;
&lt;li&gt;별도로 지정하지 않으면 커널의 기본 동작 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;지정되지 않는 시그널을 받으면 기본적으로 지정된 핸들러가 동작&lt;/li&gt;
&lt;li&gt;프로세스의 PCB 내부에 해당 프로세스에서 블록된 혹은 처리해야하는 시그널에 관련 정보를 관리함&lt;/li&gt;
&lt;li&gt;커널모드에서 사용자모드로 전환 할 때 PCB의 대기중인 시그널을 확인해 커널모드를 유지하는 경우도 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;소켓 (Socket)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;서버와 클라이언트 등 두개의 다른 컴퓨터간 네트워크 기반 통신을 위한 기술&lt;/li&gt;
&lt;li&gt;소켓을 시스템 콜로 사용해 하나의 컴퓨터 안에서 두 개의 프로세스간의 통신 기법으로 활용할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;마무리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;하나의 코드를 실행하게 되면 다음의 단계를 따라 진행된다.
&lt;ol&gt;
&lt;li&gt;프로세스 생성 후 NEW 상태로 변경&lt;/li&gt;
&lt;li&gt;메모리에 스택, 힙, 데이터(BBS, DATA), 코드 영역이 할당&lt;/li&gt;
&lt;li&gt;소스코드 텍스트가 코드 영역에 입력&lt;/li&gt;
&lt;li&gt;전역 변수를 데이터 영역에 입력&lt;/li&gt;
&lt;li&gt;프로세의 상태를 READY 상태로 전환&lt;/li&gt;
&lt;li&gt;스케쥴러에 의해 컨텍스트 스위칭이 일어나 RUNNING 상태로 전환&lt;/li&gt;
&lt;li&gt;프로세스의 PCB를 불러와서 PC와 SP를 초기화&lt;/li&gt;
&lt;li&gt;코드의 메인함수를 실행 → SP를 EBP에 저장, 다음 SP에 리턴 주소를 할당&lt;/li&gt;
&lt;li&gt;함수내의 지역변수를 스택에 입력&lt;/li&gt;
&lt;li&gt;함수내의 시스템 콜이 일어나게 되면 다음의 단계를 따라 진행된다.
&lt;ol&gt;
&lt;li&gt;시스템 콜의 번호와 시스템 콜의 인자를 EAX, EBX에 저장한 뒤, 0x80 주소로 시스템 콜 인터럽트를 실행&lt;/li&gt;
&lt;li&gt;CPU의 모드가 커널 모드로 변경&lt;/li&gt;
&lt;li&gt;IDT에서 0x80에 해당하는 주소의 함수를 찾아서 호출&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;system_call&lt;/code&gt;함수에서 EAX에 저장된 시스템 콜의 번호를 찾아서, 해당 번호에 맞는 시스템 콜 함수로 이동&lt;/li&gt;
&lt;li&gt;해당 시스템 콜 함수를 실행한 뒤, 다시 사용자 모드로 변경하고 프로세스의 다음 코드 진행&lt;/li&gt;
&lt;li&gt;만약 시스템 콜 함수에 대기가 필요하다면 프로세스의 상태를 WAITING으로 변경 한다&lt;/li&gt;
&lt;li&gt;시스템 콜의 처리가 끝나면 인터럽트를 통해 WAITING된 프로세스를 READY상태로 바꿔준다&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;함수가 종료하게 될 때 반환값이 있다면 프로세스 레지스터의 EAX에 저장한 뒤 스택을 모두 POP한다.&lt;/li&gt;
&lt;li&gt;리턴 어드레스를 POP하게 되면 해당 주소의 코드를 실행하고 만약 반환값을 사용한다면 EAX에 저장된 값을 사용한다&lt;/li&gt;
&lt;li&gt;프로세스가 종료하게 되면 프로세스의 상태를 TERMINATED로 변경하고 종료한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[CS] 운영체제]]></title><description><![CDATA[운영체제 사용자는 응용프로그램을 이용해 원하는 작업을 실행 이 때 응용프로그램이 작업을 수행하기 위해서 시스템 자원을 요청. 운영체제는 응용프로그램이 요청한 시스템 자원을 효율적으로 분배하여 제공/회수한다. Interface…]]></description><link>https://kimjeongwonn.github.io/[CS]운영체제/</link><guid isPermaLink="false">https://kimjeongwonn.github.io/[CS]운영체제/</guid><pubDate>Mon, 16 Aug 2021 09:20:05 GMT</pubDate><content:encoded>&lt;h2&gt;운영체제&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;사용자는 응용프로그램을 이용해 원하는 작업을 실행&lt;/li&gt;
&lt;li&gt;이 때 응용프로그램이 작업을 수행하기 위해서 시스템 자원을 요청.&lt;/li&gt;
&lt;li&gt;운영체제는 응용프로그램이 요청한 시스템 자원을 효율적으로 분배하여 제공/회수한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Interface&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;사용자가 운영체제를 사용하기 위해서 인터페이스가 필요한데 Shell이 그 역할을 해줌
&lt;ul&gt;
&lt;li&gt;명령어를 통해 운영체제를 사용할 수 있음&lt;/li&gt;
&lt;li&gt;Shell 또한 일종의 응용프로그램&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;응용프로그램이 운영체제를 사용하기 위해서는 API (Application Programming Interface)이 그 역할을 한다.
&lt;ul&gt;
&lt;li&gt;API는 프로그래밍 언어별로 제공되어야 한다.&lt;/li&gt;
&lt;li&gt;함수로 제공하여 호출을 통해 운영체제를 조작한다.&lt;/li&gt;
&lt;li&gt;보통은 함수들을 묶어서 라이브러리 형태로 제공.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Shell은 사용자, API는 응용프로그램이 운영체제를 사용하기 위한 인터페이스
&lt;ul&gt;
&lt;li&gt;결국은 Shell도 API를 사용해서 동작한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;운영체제는 시스템 콜을 통해 운영체제의 기능을 사용할 수 있게 해준다.
&lt;ul&gt;
&lt;li&gt;API는 시스템 콜을 사용해 운영체제의 기능을 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;시스템 콜은 운영체제를 직접 사용하기 때문에 사용방법이 까다롭고 어렵기 때문에 API로 사용하는 것이 인간 입장에서 편리하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;사용자 → 응용프로그램 → API → 시스템 콜 → 운영체제 → 하드웨어&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;시스템 콜과 API&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템 콜 : 운영체제가 제공하는 기능 호출 함수
&lt;ul&gt;
&lt;li&gt;유닉스 계열은 보통 POSIX API를 기준으로 시스템콜을 정의&lt;/li&gt;
&lt;li&gt;커널 모드에서 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;API : 각 언어별로 시스템 콜을 호출할 수 있는 Wrapper 함수
&lt;ul&gt;
&lt;li&gt;사용자 모드에서 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CPU Protection Rings&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CPU는 권한 모드를 갖고 있음
&lt;ul&gt;
&lt;li&gt;사용자 모드 → 일반적인 명령을 실행할 수 있음
&lt;ul&gt;
&lt;li&gt;응용 프로그램에서 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;커널 모드 → 특권 명령어 실행과 자원 접근을 가능하게 해줌
&lt;ul&gt;
&lt;li&gt;운영체제에서 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;인텔 CPU 기준으로 &lt;code class=&quot;language-text&quot;&gt;Ring3&lt;/code&gt; ~ &lt;code class=&quot;language-text&quot;&gt;Ring0&lt;/code&gt;까지 권한이 있음
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Ring3&lt;/code&gt;을 보통 사용자 모드라고 지칭&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Ring0&lt;/code&gt;를 보통 커널 모드라고 지칭&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CPU에서는 현재 모드를 참조하여 권한이 없는 명령을 차단하여 보호&lt;/li&gt;
&lt;li&gt;사용자가 응용프로그램을 사용할 때 커널 모드에서 조작해야 하는 명령은 API와 시스템 콜을 통해 운영체제가 커널모드에서 CPU에게 명령을 전달&lt;/li&gt;
&lt;li&gt;보통 하드웨어에 접근해야 하는 경우 커널 모드에서 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Kernel&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;사전적 의미로 &lt;code class=&quot;language-text&quot;&gt;알맹이 / 핵심&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;운영체제의 핵심적인 알맹이&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Shell&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;사전적 의미로 껍데기&lt;/li&gt;
&lt;li&gt;운영체제의 핵심적인 기능을 감싸는 껍데기&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[자바스크립트의 핵심 '실행 컨텍스트']]></title><description><![CDATA[자바스크립트를 공부하면서 개인적으로 자바스크립트에서 가장 중요한 개념을 꼽자면 를 꼽는다. 자바스크립트의 핵심 개념들을 나열 해 보라고 한다면 보통 프로토타입, this…]]></description><link>https://kimjeongwonn.github.io/자바스크립트의-핵심-실행컨텍스트/</link><guid isPermaLink="false">https://kimjeongwonn.github.io/자바스크립트의-핵심-실행컨텍스트/</guid><pubDate>Mon, 16 Aug 2021 05:59:05 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트를 공부하면서 개인적으로 자바스크립트에서 가장 중요한 개념을 꼽자면 &lt;code class=&quot;language-text&quot;&gt;실행 컨텍스트&lt;/code&gt;를 꼽는다. 자바스크립트의 핵심 개념들을 나열 해 보라고 한다면 보통 프로토타입, this 바인딩, 호이스팅, 렉시컬 스코프, 클로저, 이벤트 루프등을 떠올릴 수 있고 그 중에서도 앞의 개념들을 관통하는 가장 핵심적인 개념이 &lt;code class=&quot;language-text&quot;&gt;실행 컨텍스트&lt;/code&gt;이다.&lt;/p&gt;
&lt;h2&gt;실행 환경&lt;/h2&gt;
&lt;p&gt;실행 컨텍스트(이하 EC; Execution Context)는 실행 컨텍스트 스택에서 구성된다. 그리고 모든 코드는 EC 안에서 작동한다. 코드가 평가되기 위해서 자바스크립트 엔진은 EC를 생성한 뒤 코드를 평가하는데 EC가 생성되는 상황은 크게 세가지가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;전역 코드의 실행 → 전역 EC 생성&lt;/li&gt;
&lt;li&gt;함수의 실행 → 함수 EC 생성&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt;코드의 실행 → eval EC 생성&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;실행 컨텍스트 스택과 콜 스택은 같은 의미이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;EC가 생성되면 생성 단계와 실행 단계를 거쳐 코드를 실행하게 된다. 생성 단계에서는 코드를 전체적으로 평가하고 렉시컬 환경(Lexical Environment)을 생성한다. 그리고 그 렉시컬 환경 내에서는 스코프 체인을 위한 외부 렉시컬 환경 참조 바인딩(Outer Lexical Environment Reference), 식별자 탐색을 위한 객체 환경 레코드(Object Environment Recode)가 연결되고, 전역EC의 경우에는 let과 const로 선언된 변수/상수를 저장하는 선언 환경 레코드(Declarative Environment Record)가 환경 레코드에 연결된다. 마지막으로 해당 렉시컬 환경의 this를 결정하는 this 참조 바인딩이 처리된다.&lt;/p&gt;
&lt;p&gt;추가로 ES6이후부터는 블록 스코프별로 렉시컬 환경이 새로 생성되고 현재 실행중인 EC의 렉시컬 환경을 교체하는 식으로 스코프를 처리한다. 이 때 외부 렉시컬 환경 참조를 블럭문이 정의되었던 렉시컬 환경으로 바인딩 하여, 블록 스코프 내에서 스코프 체인이 일어날 수 있도록 해준다.
이렇게 렉시컬 환경과 변수 환경이 생성하면서 식별자에 대한 호이스팅이 일어나게 되고 var변수에는 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;를 let과 const에는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;uninitialized&gt;&lt;/code&gt;로 초기화하여 미리 식별자를 할당하게 된다. 이후에 코드가 실행되면서 실제 변수 할당이 일어난다.&lt;/p&gt;
&lt;p&gt;var로 선언된 변수를 저장하기 위한 변수 환경(Variable Environment)도 함께 EC에 연결된다. 변수 환경은 EC 별로 생성되기 때문에 EC내에서 렉시컬 환경이 변경되어도(블록문 실행 등) var변수에 접근할 수 있게 해준다.&lt;/p&gt;
&lt;h2&gt;전역 EC&lt;/h2&gt;
&lt;p&gt;브라우저의 렌더링 단계에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&gt;&lt;/code&gt;태그를 만나면 자바스크립트 엔진에서 EC 스택에 전역 EC를 생성한다. 전역 EC에는 객체 환경 레코드를 통해 globalThis객체에 참조할 수 있게끔 연결이 되며 globalThis또한 별도로 바인딩된다. 일반적으로 전역에서 this를 참조하게 되면 globalThis에 연결되지만 strict mode에서는 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;로 연결이 된다.&lt;/p&gt;
&lt;p&gt;전역 EC의 전역 렉시컬 환경은 별도의 선언 환경 레코드를 갖고 있는데, 이곳에는 let과 const로 선언 된 변수/상수를 별도로 관리한다. var 변수의 경우 globalThis의 프로퍼티로 등록 된 후 변수 환경에서 참조되는 방식으로 식별자를 갖는다면 let과 const는 별도의 공간에 저장되어 globalThis의 프로퍼티와 충돌을 방지한다.&lt;/p&gt;
&lt;p&gt;이 후 코드 실행 단계에서 함수 객체가 생성되게 된다면 현재 실행 컨텍스트에 바인딩 된 렉시컬 환경을 함수 객체의 내부슬롯 &lt;code class=&quot;language-text&quot;&gt;[[Environment]]&lt;/code&gt;에 바인딩하여 이후 함수가 호출 되었을 때의 외부 렉시컬 환경 참조를 결정할 수 있도록 한다.&lt;/p&gt;
&lt;h3&gt;블록 렉시컬 환경&lt;/h3&gt;
&lt;p&gt;ES6의 let과 const는 블록레벨 스코프를 갖는다. 그렇기 때문에 블록문이 실행 될때 EC는 그대로 유지 된 채로 렉시컬 환경의 바인딩이 교체되는 방법으로 새로운 스코프를 갖게 된다. 이 때 블록 렉시컬 환경이 생성되는데 블록문 내에서의 식별자를 저장하고 외부 렉시컬 환경 참조는 원래 바인딩 되어있었던 렉시컬 환경을 가르켜 스코프 체인을 생성한다.&lt;/p&gt;
&lt;h2&gt;함수 EC&lt;/h2&gt;
&lt;p&gt;자바스크립트 엔진에서 함수가 호출되면 EC 스택에 함수 EC를 생성한다. 이 때의 EC 스택에는 전역 EC가 있을 수도 있고, 이벤트 루프를 통해 호출된다면 비어있을 수도 있다. 함수 EC가 생성되면 EC 생성 단계에 진입하여 함수 렉시컬 환경을 만들고 이 때 함수가 호출된 방법에 따라 this가 결정되고 외부 렉시컬 환경 참조에 호출된 함수 객체의 &lt;code class=&quot;language-text&quot;&gt;[[Environment]]&lt;/code&gt; 내부 슬롯에 연결된 렉시컬 환경을 바인딩하여 렉시컬 스코프를 생성한다.&lt;/p&gt;
&lt;p&gt;이후 함수 환경 레코드를 생성하여 매개변수와 arguments변수를 초기화하고 함수 내부에서 선언된 식별자들을 초기화 한다. (호이스팅) 이 때 var와 let, const를 별도로 분리하지 않고 함수 환경 레코드 내에서 모두 초기화 한다. 다음 코드 실행 단계에서 초기화 된 식별자에 할당이 일어난다. 만약 이 때 함수 내부에서 함수가 선언된다면 해당 함수객체의 내부슬롯 &lt;code class=&quot;language-text&quot;&gt;[[Environment]]&lt;/code&gt;에 &lt;em&gt;함수가 선언된 함수의 렉시컬 환경&lt;/em&gt;이 바인딩 되고 만약 선언된 함수가 반환되거나 외부에 할당되어 해당 함수 EC가 삭제된 이후에도 남아있다면 연결된 렉시컬 환경은 &lt;code class=&quot;language-text&quot;&gt;[[Environment]]&lt;/code&gt;의 참조로 남아 클로저를 생성한다.&lt;/p&gt;
&lt;p&gt;eval EC의 경우도 비슷하게 작동하며 eval코드는 자바스크립트의 대표적인 안티패턴이므로 거의 사용되지 않기 때문에 생략한다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;개인적으로는 자바스크립트의 작동 원리는 실행 컨텍스트에 대한 치밀한 이해만 있다면 반 이상은 이해할 수 있다고 생각한다. 때문에 자바스크립트를 제대로 공부한다면 반드시 적확하게 이해할 필요가 있는 부분이기 때문에 한 번 더 정리를 했다. 이미 알고 있는 내용임에도 용어나 원리가 헷갈리기도 했다. 이 매커니즘을 머릿속에서 언제든지 그릴 수 있을 때 까지 계속 공부해야 할 필요가 있다고 생각한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[자바스크립트 동등비교연산자 (==)]]></title><description><![CDATA[…]]></description><link>https://kimjeongwonn.github.io/자바스크립트-동등비교연산자-(==)/</link><guid isPermaLink="false">https://kimjeongwonn.github.io/자바스크립트-동등비교연산자-(==)/</guid><pubDate>Wed, 11 Aug 2021 10:36:56 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트에서는 비교연산이 두가지 있다. &lt;code class=&quot;language-text&quot;&gt;==&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt; 로 전자는 동등비교연사자, 후자는 일치비교연산자라고 부르기도 한다. (일단 나는 그렇게 부른다.) 대부분의 자바스크립트 개발자들은 두 비교연산자의 차이점은 비교연산시에 동적으로 타이핑을 하느냐로 알고 있을 것이고, 나도 그랬었다. 그렇다면 아래 표현식들의 결과는 어떻게 나올까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;결론부터 말하자면 둘 다 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;가 나온다. 우리는 동등 비교연산&lt;code class=&quot;language-text&quot;&gt;==&lt;/code&gt;을 하게되면 양쪽의 피연산자의 값을 형변환을 이용한 뒤 일치연산을 하는 것으로 알고있다. 그렇다면 일반적으로 아래와 같은 방식으로 비교할 것이라고 기대한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// []를 boolean으로 형변환 한다&lt;/span&gt;
&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true를 반환한다&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// null을 0으로 형변환 한다&lt;/span&gt;
&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true를 반환한다&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그런데 왜 둘 다 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;가 나오는 것일까? 정답은 자바스크립트는 동등 비교 연산시에 ECMAScript에서 지정한 &lt;a href=&quot;https://262.ecma-international.org/5.1/#sec-11.9.3&quot;&gt;동등 비교 연산 알고리즘&lt;/a&gt;을 통해 형변환을 진행하기 때문이다. 그 중에는 다음과 같은 내용이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.&lt;/li&gt;
&lt;li&gt;If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그렇다. 양쪽의 피연산자 중 하나가 &lt;strong&gt;boolean일 경우 number로 형변환을 한 뒤 비교한다&lt;/strong&gt;는 내용이다. 왜 동등 비교연산에서 이런 짓을 하는지는 브렌던 아이크씨가 알겠지만, 일단은 동등 비교연산에서는 위의 알고리즘을 따른다는 것이다. 그럼 다시 &lt;code class=&quot;language-text&quot;&gt;[] == true&lt;/code&gt;가 어떻게 작동하는지 생각 해 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// boolean인 true를 number로 형변환 한다&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true를 number로 바꾸면 1이다. 이제 빈 배열을 number로 형변환 한다&lt;/span&gt;
&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 빈 배열을 number로 바꾸면 0이 나온다 (1이 아니다) 결국 0과 1을 비교하게 되어서 false가 출력된다.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런 과정을 거쳐 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;가 출력되는 것이었다. 왜 이따위로 만들었는지는 정말 모르겠다.&lt;/p&gt;
&lt;p&gt;그럼, &lt;code class=&quot;language-text&quot;&gt;null == 0&lt;/code&gt;이 안되는 이유는? 역시 동등 비교 연산 알고리즘에 답이 있다. 해당 문서에 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;에 대한 정의는 아래의 두개 뿐이다.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;If x is null and y is undefined, return true.&lt;/li&gt;
&lt;li&gt;If x is undefined and y is null, return true.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;즉 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;undifined&lt;/code&gt;는 서로 비교했을 때 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;를 반환하고 다른 연산시에는 형변환을 하지 않는다. 그렇기 때문에 &lt;code class=&quot;language-text&quot;&gt;null == 0&lt;/code&gt;을 했을 때 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;은 아예 형변환을 하지 않게되고 그대로 비교하게 되기 때문에 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;를 반환하게 된다.&lt;/p&gt;
&lt;p&gt;보통 자바스크립트를 학습할 때 동등비교연산&lt;code class=&quot;language-text&quot;&gt;==&lt;/code&gt; 보다는 일치비교연산&lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt;을 사용하라고 배우게 된다. 그리고 사실 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt;만 사용하게 되면 위의 문제로 고민할 필요도 없다. 그럼에도 개발자로서 &lt;strong&gt;왜?&lt;/strong&gt; 라는 질문을 해보는 것이 중요하다. 위 사실을 알게 되었든 아니든 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt;만을 사용하면 이런 문제를 고민할 필요는 없겠지만 그럼에도 동등비교연산의 매커니즘을 적확히 파악하여 다음과 같은 상황에 대한 처리방법을 생각 할 수 있었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;만약 어떤 값에 대하여 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;이 들어올지 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;가 들어올지 확실하지 않은 상황에서,
&lt;code class=&quot;language-text&quot;&gt;if (value == null) {}&lt;/code&gt;과 같은 방법으로 &lt;code class=&quot;language-text&quot;&gt;nullish&lt;/code&gt;한 값에 대한 처리가 가능해 진다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[이터러블/이터레이터/제네레이터]]></title><description><![CDATA[자바스크립트 공부중 어려웠던 내용을 복습해 보려고 한다. 그 중 하나가 Iterable / Iterator / Generator 였다. 패스트캠퍼스 Nodejs…]]></description><link>https://kimjeongwonn.github.io/이터러블-이터레이터-제네레이터/</link><guid isPermaLink="false">https://kimjeongwonn.github.io/이터러블-이터레이터-제네레이터/</guid><pubDate>Sun, 14 Jun 2020 02:04:07 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트 공부중 어려웠던 내용을 복습해 보려고 한다. 그 중 하나가 Iterable / Iterator / Generator 였다. 패스트캠퍼스 Nodejs 올인원 패키지에서는 제대로 설명해 주지 않아서 조금 아쉬웠다. 강좌의 분량을 생각하면 어쩔 수 없기도 했지만, 이해하는데 꽤나 시간을 많이 들였다. 물론 지금도 바로 설명하라고 하면 한참을 어버버 거릴 것 같다. 지식의 상태로 있는 내용들을 내것으로 만드는 건 반복 학습 뿐이라고 생각되기 때문에 다시 한 번 정리해 본다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5&gt;참고 자료 :&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://poiemaweb.com/es6-iteration-for-of&quot;&gt;https://poiemaweb.com/es6-iteration-for-of&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://poiemaweb.com/es6-generator&quot;&gt;https://poiemaweb.com/es6-generator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Iteration Protocol&lt;/h1&gt;
&lt;p&gt;ES6에서 새로 도입된 데이터 컬렉션 객체(대표적으로 Array)를 순회하기 위한 Protocol(정의된 규칙)이다. 이 프로토콜을 준수한 객체만이 for of 문으로 순회할 수 있고 Spread문법의 피연산자가 될 수 있다. Iteration Protocol은 Iterable Protocol과 Iterator Protocol을 총칭한다.&lt;/p&gt;
&lt;h2&gt;1. 이터러블(Iterable)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Symbol.iterator를 키로 갖고있는 메소드를 가지고 있는 객체를 말한다.&lt;/strong&gt; 별도로 Symbol.iterator를 키로 하여 메소드를 정의해 주거나 프로토타입 상속을 통해서 Symbol.iterator를 키로 갖고있는 메소드를 갖고 있다면 Iterable Protocol의 조건을 충족하여 Iterable이라고 할 수 있다. Iterable객체는 for of문으로 순회할 수 있고 Spread문법의 피연산자로 사용할 수 있다. 대표적으로 Array 객체가 있다. &lt;em&gt;(ES9부터는 Object도 피연산자로 사용할 수 있다.)&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; array &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Symbol&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;iterator &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//true&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; item &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;item&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.1 빌트인 이터러블&lt;/h3&gt;
&lt;p&gt;ES6를 기준으로 이터러블을 지원하는 객체는 아래와 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Array, String, Map, Set, TypedArray(Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array), DOM data structure(NodeList, HTMLCollection), &lt;em&gt;Arguments&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2. 이터레이터(Iterator)&lt;/h2&gt;
&lt;p&gt;이터러블 객체의 Symbol.iterator 메소드를 호출하면 Iterator객체를 반환한다. 반환된 Iterator객체는 next메소드를 소유하고 있으며 next메소드를 호출할 때 iterator result 객체를 반환한다면 Iterator Protocol을 충족하여 Iterator라고 할 수 있다. iterator result 객체는 value와 done 프로퍼티를 갖고 있으며, value는 현재 순회하는 값을 갖고 있고 done은 순회가 언제 끝나는지 알려준다. next메소드는 반복적을 호출되다가 모든 요소를 순회하게 되면 value프로퍼티는 undefined, done프로퍼티는 true가 되며 순회를 중단한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; array &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; iterator &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;Symbol&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;itrator&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//Symbol.itrator를 호출해서 반환된 iterator를 받는다.&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;iterator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//반복&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//{ value: 1, done: false }&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//{ value: 2, done: false }&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//{ value: 3, done: false }&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//{ value: 4, done: false }&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//{ value: 5, done: false }&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//{ value: undefined, done: true }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images.velog.io/images/kimjeongwonn/post/32adbcb3-27a2-4ddc-97e1-b3b0ed4f2c1b/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;3. 이터러블 객체 순회하기&lt;/h2&gt;
&lt;p&gt;Iteration Protocol을 준수하는 객체를 순회하는 반복문/연산자가 있는데 대표적으로는 for of문이 있다. 이런 반복문/연산자들은 Iterable 객체에서 Iterator를 조작하여 iterator result를 참조해 명령을 실행한다.&lt;/p&gt;
&lt;h3&gt;3.1 for of문&lt;/h3&gt;
&lt;p&gt;for of문은 해당하는 객체의 Iterator를 통해 받는 iterator result객체의 done프로퍼티가 true가 될 때까지 value프로퍼티의 값을 순회하며 변수에 할당한다. 위의 빌트인 이터러블안의 객체는 모두 순환이 가능하기 때문에 문자열도 순환이 가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//배열&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; i &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//1 2 3 4 5&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//문자열&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; i &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;abcde&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//&apos;a&apos; &apos;b&apos; &apos;c&apos; &apos;d&apos; &apos;e&apos;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4. 제네레이터(Generator)&lt;/h2&gt;
&lt;p&gt;직접 이터러블 객체를 만들 수도 있다. 먼저, Iteration Protocol에 맞춰 &lt;em&gt;value와 done프로퍼티를 return하는 next메소드를 return하는 Symbol.iterator 메소드&lt;/em&gt; 를 직접 작성하여 객체에 할당해주는 방법도 있지만 제네레이터 함수를 이용해 더 쉽게 이터러블 객체를 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;아래 예제를 통해 제네레이터의 생성과 순회를 살펴보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//function* 을 통해 제네레이터 함수를 만들 수 있다. (화살표 함수는 사용할 수 없다.)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; 
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Point 1&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
  &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
  &lt;span class=&quot;token comment&quot;&gt;//next 메소드를 호출하면 yield까지의 명령이 처리된 뒤, yield에서 반환되는 값이 iterator result 객체의 value에 할당된다. 그 뒤 다음 next메소드가 호출 될 때 까지 대기한다.&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Point 2&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Point 3&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;done&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//모든 순회가 끝나고 done 프로퍼티가 true가 된다.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; generatorObj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;/* 제네레이터 함수를 호출해서 제네레이터 객체를 생성한다.
제네레이터를 통해 생성된 객체는 이터러블이면서 이터레이터이기 때문에 굳이 Symbol.iterator를 호출하지 않아도 next메소드를 통해 순회할 수 있다. */&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; i &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; generatorObj &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//이터러블 객체이기 때문에 for of 문으로 바로 순회가 가능하다. &lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//물론 이터레이터이기도 하기 때문에 next메소드를 호출하여 원하는 시점에서 호출이 가능하다.&lt;/span&gt;

generatorObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//next를 통해 순회하게 되면 yield로 반환된 값을 value프로퍼티의 값으로 갖는 iterator result 객체가 반환된다. 제네레이터 함수 안에 마지막 yield가 끝난 뒤에는 done프로퍼티는 true가 되며 순회가 종료된다.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 예제의 &lt;strong&gt;제네레이터 함수&lt;/strong&gt;를 통해 &lt;strong&gt;&lt;em&gt;이터러블이면서 이터레이터인&lt;/em&gt; 제네레이터 객체&lt;/strong&gt;를 생성하고 생성된 제네레이터 객체는 이터러블 처럼 for of를 통해 순회하거나 이터레이터 처럼 next메소드를 통해 순회할 수 있다.&lt;/p&gt;
&lt;h3&gt;4.1 제네레이터에 인수를 전달하여 호출하기&lt;/h3&gt;
&lt;p&gt;제네레이터 함수는 함수이기 때문에 인자를 받아 제네레이터 객체를 생성할 수 있다.
다음과 같이 인자로 입력받은 횟수만큼 반복하는 제네레이터를 생성해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt;n &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;current number : &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;i&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;, last number : &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;n&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; genObj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//10번 순회할 수 있는 제네레이터 오브젝트를 생성&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//반복 호출하면 아래와 같은 콘솔을 볼 수 있다.&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/*
제네레이터 함수 안에 있는 console.log가 출력
current number : 1, last number : 10
next메소드가 반환된 iterble result가 console.log를 통해 출력
{value: 0, done: false}
... 계속 순회하다가 인자로 넣은 마지막 숫자에 도달하면 아래와 같이 done이 true가 되어 순회를 종료
current number : 10, last number : 10
{value: 10, done: false}
{value: undefined, done: true}
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.2 next메소드에 인수를 전달하여 제네레이터 호출하기&lt;/h3&gt;
&lt;p&gt;제네레이터는 이터레이터와는 다르게 next메소드에 인자를 전달하면 제네레이터 함수의 yield에 할당되어 작동한다. 이를 통해 좀 더 유연하게 제네레이터를 활용할 수 있다.
아래의 예제를 통해 인자가 어떻게 전달되는지 알 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; n&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
 
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; genObj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//0 으로 초기값 지정&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//제네레이터 함수 시작 =&gt; value:0&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//yield에 1을 전달 이후 함수 다시시작&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//반복&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//더이상 yield가 없기 때문에 종료&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//{ value: undefined, done: true }&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/*
{ value: 0, done: false }
{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }

*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;next메소드에 인수가 있을 경우에는 yield는 두가지 역할을 하게 된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;value값 반환&lt;/li&gt;
&lt;li&gt;next의 인수를 변수에 할당&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;먼저 res에 리터럴을 할당하기 위해서 자바스크립트가 yield n을 처리하게 된다. &lt;strong&gt;그 과정에서 yield가 처리되면서 다음 next까지 함수가 일시정지 되게 된다.&lt;/strong&gt; 그리고 다음 next가 호출 될 때 받은 인자를 yield가 반환하여 res변수에 할당하게 된다. 그리고 다시 다음 yield까지 실행한 뒤 일시정지 된다. 이 과정이 마지막 yield까지 반복된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.velog.io/images/kimjeongwonn/post/ccdb0940-e2fd-4b12-b7bb-f25a8bb52570/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;4.3 return을 통해 제네레이터를 강제 종료&lt;/h3&gt;
&lt;p&gt;제네레이터 함수 안에서 return이 실행되는 즉시 done은 true가 되고 return에서 반환된 값을 가진 iterator result 객체가 반환된 뒤 제네레이터가 종료된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;end&apos;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; genObj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//반복&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;/*
{value: 0, done: false}
{value: 1, done: false}
{value: 2, done: false}
{value: 3, done: false}
{value: 4, done: false}
{value: 5, done: false} //for of 등을 통한 순회에서는 여기까지만 순회한다.
{value: &apos;end&apos;, done: true}
{value: undefined, done: true}
...
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;return에서 값을 반환하면서 동신에 done이 true가 되기 때문에 for of문 들을 통한 순회에서는 그 전의 값까지만 순회한다.&lt;/p&gt;
&lt;h3&gt;4.4 비동기 처리&lt;/h3&gt;
&lt;p&gt;함수의 비동기 처리도 제네레이터를 통해 구현할 수 있지만 ES8의 async/await가 완전히 그 기능을 대체하고 있으니 이곳에 설명은 생략한다.&lt;/p&gt;
&lt;h1&gt;마치며&lt;/h1&gt;
&lt;p&gt;첫 번째 복습기록이다. 내가 이해가 안되었던 부분들을 최대한 이해할 수 있도록 풀어 썼다. 개인적으로는 next메소드에 인수를 넣어 호출할 때 어째서 인수로 넣은 값이 res에 할당된 뒤 console.log로 출력되는지 계속 고민했고, 그렇게 알게 된 내용을 좀 더 자세히 서술했다. 물론 다른 사람들은 당연하게 이해하고 넘어갈 수 있는 부분이었더라도 나는 저 부분이 쉽게 넘어가지지 않았다. 또한 나도 이렇게 복습/복기를 하면서 새로운 사실도 알게되었다. 현재는 React를 배우고 있는데 당연한 듯이 Object 객체에 Spread 연산을 쓰는 강의를 보면서 Object는 이터러블이 아닌데 어떻게 Spread연산이 동작하나 싶었는데 ES9부터 Object에서 Spread연산이 작동한다는 사실도 알게되었다.&lt;/p&gt;</content:encoded></item></channel></rss>