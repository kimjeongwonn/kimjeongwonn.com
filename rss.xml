<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[kimjeongwonn]]></title><description><![CDATA[김정원의 프론트엔드 기술블로그]]></description><link>https://kimjeongwonn.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 16 Aug 2021 05:58:56 GMT</lastBuildDate><item><title><![CDATA[자바스크립트의 핵심 '실행 컨텍스트']]></title><description><![CDATA[자바스크립트를 공부하면서 개인적으로 자바스크립트에서 가장 중요한 개념을 꼽자면 를 꼽는다. 자바스크립트의 핵심 개념들을 나열 해 보라고 한다면 보통 프로토타입, this…]]></description><link>https://kimjeongwonn.github.io/자바스크립트의-핵심-실행컨텍스트/</link><guid isPermaLink="false">https://kimjeongwonn.github.io/자바스크립트의-핵심-실행컨텍스트/</guid><content:encoded>&lt;p&gt;자바스크립트를 공부하면서 개인적으로 자바스크립트에서 가장 중요한 개념을 꼽자면 &lt;code class=&quot;language-text&quot;&gt;실행 컨텍스트&lt;/code&gt;를 꼽는다. 자바스크립트의 핵심 개념들을 나열 해 보라고 한다면 보통 프로토타입, this 바인딩, 호이스팅, 렉시컬 스코프, 클로저, 이벤트 루프등을 떠올릴 수 있고 그 중에서도 앞의 개념들을 관통하는 가장 핵심적인 개념이 &lt;code class=&quot;language-text&quot;&gt;실행 컨텍스트&lt;/code&gt;이다.&lt;/p&gt;
&lt;h2&gt;실행 환경&lt;/h2&gt;
&lt;p&gt;실행 컨텍스트(이하 EC; Execution Context)는 실행 컨텍스트 스택에서 구성된다. 그리고 모든 코드는 EC 안에서 작동한다. 코드가 평가되기 위해서 자바스크립트 엔진은 EC를 생성한 뒤 코드를 평가하는데 EC가 생성되는 상황은 크게 세가지가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;전역 코드의 실행 → 전역 EC 생성&lt;/li&gt;
&lt;li&gt;함수의 실행 → 함수 EC 생성&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt;코드의 실행 → eval EC 생성&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;실행 컨텍스트 스택과 콜 스택은 같은 의미이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;EC가 생성되면 생성 단계와 실행 단계를 거쳐 코드를 실행하게 된다. 생성 단계에서는 코드를 전체적으로 평가하고 렉시컬 환경(Lexical Environment)을 생성한다. 그리고 그 렉시컬 환경 내에서는 스코프 체인을 위한 외부 렉시컬 환경 참조 바인딩(Outer Lexical Environment Reference), 식별자 탐색을 위한 객체 환경 레코드(Object Environment Recode)가 연결되고, 전역EC의 경우에는 let과 const로 선언된 변수/상수를 저장하는 선언 환경 레코드(Declarative Environment Record)가 환경 레코드에 연결된다. 마지막으로 해당 렉시컬 환경의 this를 결정하는 this 참조 바인딩이 처리된다.&lt;/p&gt;
&lt;p&gt;추가로 ES6이후부터는 블록 스코프별로 렉시컬 환경이 새로 생성되고 현재 실행중인 EC의 렉시컬 환경을 교체하는 식으로 스코프를 처리한다. 이 때 외부 렉시컬 환경 참조를 블럭문이 정의되었던 렉시컬 환경으로 바인딩 하여, 블록 스코프 내에서 스코프 체인이 일어날 수 있도록 해준다.
이렇게 렉시컬 환경과 변수 환경이 생성하면서 식별자에 대한 호이스팅이 일어나게 되고 var변수에는 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;를 let과 const에는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;uninitialized&gt;&lt;/code&gt;로 초기화하여 미리 식별자를 할당하게 된다. 이후에 코드가 실행되면서 실제 변수 할당이 일어난다.&lt;/p&gt;
&lt;p&gt;var로 선언된 변수를 저장하기 위한 변수 환경(Variable Environment)도 함께 EC에 연결된다. 변수 환경은 EC 별로 생성되기 때문에 EC내에서 렉시컬 환경이 변경되어도(블록문 실행 등) var변수에 접근할 수 있게 해준다.&lt;/p&gt;
&lt;h2&gt;전역 EC&lt;/h2&gt;
&lt;p&gt;브라우저의 렌더링 단계에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&gt;&lt;/code&gt;태그를 만나면 자바스크립트 엔진에서 EC 스택에 전역 EC를 생성한다. 전역 EC에는 객체 환경 레코드를 통해 globalThis객체에 참조할 수 있게끔 연결이 되며 globalThis또한 별도로 바인딩된다. 일반적으로 전역에서 this를 참조하게 되면 globalThis에 연결되지만 strict mode에서는 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;로 연결이 된다.&lt;/p&gt;
&lt;p&gt;전역 EC의 전역 렉시컬 환경은 별도의 선언 환경 레코드를 갖고 있는데, 이곳에는 let과 const로 선언 된 변수/상수를 별도로 관리한다. var 변수의 경우 globalThis의 프로퍼티로 등록 된 후 변수 환경에서 참조되는 방식으로 식별자를 갖는다면 let과 const는 별도의 공간에 저장되어 globalThis의 프로퍼티와 충돌을 방지한다.&lt;/p&gt;
&lt;p&gt;이 후 코드 실행 단계에서 함수 객체가 생성되게 된다면 현재 실행 컨텍스트에 바인딩 된 렉시컬 환경을 함수 객체의 내부슬롯 &lt;code class=&quot;language-text&quot;&gt;[[Environment]]&lt;/code&gt;에 바인딩하여 이후 함수가 호출 되었을 때의 외부 렉시컬 환경 참조를 결정할 수 있도록 한다.&lt;/p&gt;
&lt;h3&gt;블록 렉시컬 환경&lt;/h3&gt;
&lt;p&gt;ES6의 let과 const는 블록레벨 스코프를 갖는다. 그렇기 때문에 블록문이 실행 될때 EC는 그대로 유지 된 채로 렉시컬 환경의 바인딩이 교체되는 방법으로 새로운 스코프를 갖게 된다. 이 때 블록 렉시컬 환경이 생성되는데 블록문 내에서의 식별자를 저장하고 외부 렉시컬 환경 참조는 원래 바인딩 되어있었던 렉시컬 환경을 가르켜 스코프 체인을 생성한다.&lt;/p&gt;
&lt;h2&gt;함수 EC&lt;/h2&gt;
&lt;p&gt;자바스크립트 엔진에서 함수가 호출되면 EC 스택에 함수 EC를 생성한다. 이 때의 EC 스택에는 전역 EC가 있을 수도 있고, 이벤트 루프를 통해 호출된다면 비어있을 수도 있다. 함수 EC가 생성되면 EC 생성 단계에 진입하여 함수 렉시컬 환경을 만들고 이 때 함수가 호출된 방법에 따라 this가 결정되고 외부 렉시컬 환경 참조에 호출된 함수 객체의 &lt;code class=&quot;language-text&quot;&gt;[[Environment]]&lt;/code&gt; 내부 슬롯에 연결된 렉시컬 환경을 바인딩하여 렉시컬 스코프를 생성한다.&lt;/p&gt;
&lt;p&gt;이후 함수 환경 레코드를 생성하여 매개변수와 arguments변수를 초기화하고 함수 내부에서 선언된 식별자들을 초기화 한다. (호이스팅) 이 때 var와 let, const를 별도로 분리하지 않고 함수 환경 레코드 내에서 모두 초기화 한다. 다음 코드 실행 단계에서 초기화 된 식별자에 할당이 일어난다. 만약 이 때 함수 내부에서 함수가 선언된다면 해당 함수객체의 내부슬롯 &lt;code class=&quot;language-text&quot;&gt;[[Environment]]&lt;/code&gt;에 &lt;em&gt;함수가 선언된 함수의 렉시컬 환경&lt;/em&gt;이 바인딩 되고 만약 선언된 함수가 반환되거나 외부에 할당되어 해당 함수 EC가 삭제된 이후에도 남아있다면 연결된 렉시컬 환경은 &lt;code class=&quot;language-text&quot;&gt;[[Environment]]&lt;/code&gt;의 참조로 남아 클로저를 생성한다.&lt;/p&gt;
&lt;p&gt;eval EC의 경우도 비슷하게 작동하며 eval코드는 자바스크립트의 대표적인 안티패턴이므로 거의 사용되지 않기 때문에 생략한다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;개인적으로는 자바스크립트의 작동 원리는 실행 컨텍스트에 대한 치밀한 이해만 있다면 반 이상은 이해할 수 있다고 생각한다. 때문에 자바스크립트를 제대로 공부한다면 반드시 적확하게 이해할 필요가 있는 부분이기 때문에 한 번 더 정리를 했다. 이미 알고 있는 내용임에도 용어나 원리가 헷갈리기도 했다. 이 매커니즘을 머릿속에서 언제든지 그릴 수 있을 때 까지 계속 공부해야 할 필요가 있다고 생각한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[자바스크립트 동등비교연산자 (==)]]></title><description><![CDATA[…]]></description><link>https://kimjeongwonn.github.io/자바스크립트-동등비교연산자-(==)/</link><guid isPermaLink="false">https://kimjeongwonn.github.io/자바스크립트-동등비교연산자-(==)/</guid><pubDate>Wed, 11 Aug 2021 10:36:56 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트에서는 비교연산이 두가지 있다. &lt;code class=&quot;language-text&quot;&gt;==&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt; 로 전자는 동등비교연사자, 후자는 일치비교연산자라고 부르기도 한다. (일단 나는 그렇게 부른다.) 대부분의 자바스크립트 개발자들은 두 비교연산자의 차이점은 비교연산시에 동적으로 타이핑을 하느냐로 알고 있을 것이고, 나도 그랬었다. 그렇다면 아래 표현식들의 결과는 어떻게 나올까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;결론부터 말하자면 둘 다 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;가 나온다. 우리는 동등 비교연산&lt;code class=&quot;language-text&quot;&gt;==&lt;/code&gt;을 하게되면 양쪽의 피연산자의 값을 형변환을 이용한 뒤 일치연산을 하는 것으로 알고있다. 그렇다면 일반적으로 아래와 같은 방식으로 비교할 것이라고 기대한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// []를 boolean으로 형변환 한다&lt;/span&gt;
&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true를 반환한다&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// null을 0으로 형변환 한다&lt;/span&gt;
&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true를 반환한다&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그런데 왜 둘 다 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;가 나오는 것일까? 정답은 자바스크립트는 동등 비교 연산시에 ECMAScript에서 지정한 &lt;a href=&quot;https://262.ecma-international.org/5.1/#sec-11.9.3&quot;&gt;동등 비교 연산 알고리즘&lt;/a&gt;을 통해 형변환을 진행하기 때문이다. 그 중에는 다음과 같은 내용이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.&lt;/li&gt;
&lt;li&gt;If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그렇다. 양쪽의 피연산자 중 하나가 &lt;strong&gt;boolean일 경우 number로 형변환을 한 뒤 비교한다&lt;/strong&gt;는 내용이다. 왜 동등 비교연산에서 이런 짓을 하는지는 브렌던 아이크씨가 알겠지만, 일단은 동등 비교연산에서는 위의 알고리즘을 따른다는 것이다. 그럼 다시 &lt;code class=&quot;language-text&quot;&gt;[] == true&lt;/code&gt;가 어떻게 작동하는지 생각 해 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// boolean인 true를 number로 형변환 한다&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true를 number로 바꾸면 1이다. 이제 빈 배열을 number로 형변환 한다&lt;/span&gt;
&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 빈 배열을 number로 바꾸면 0이 나온다 (1이 아니다) 결국 0과 1을 비교하게 되어서 false가 출력된다.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런 과정을 거쳐 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;가 출력되는 것이었다. 왜 이따위로 만들었는지는 정말 모르겠다.&lt;/p&gt;
&lt;p&gt;그럼, &lt;code class=&quot;language-text&quot;&gt;null == 0&lt;/code&gt;이 안되는 이유는? 역시 동등 비교 연산 알고리즘에 답이 있다. 해당 문서에 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;에 대한 정의는 아래의 두개 뿐이다.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;If x is null and y is undefined, return true.&lt;/li&gt;
&lt;li&gt;If x is undefined and y is null, return true.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;즉 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;undifined&lt;/code&gt;는 서로 비교했을 때 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;를 반환하고 다른 연산시에는 형변환을 하지 않는다. 그렇기 때문에 &lt;code class=&quot;language-text&quot;&gt;null == 0&lt;/code&gt;을 했을 때 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;은 아예 형변환을 하지 않게되고 그대로 비교하게 되기 때문에 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;를 반환하게 된다.&lt;/p&gt;
&lt;p&gt;보통 자바스크립트를 학습할 때 동등비교연산&lt;code class=&quot;language-text&quot;&gt;==&lt;/code&gt; 보다는 일치비교연산&lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt;을 사용하라고 배우게 된다. 그리고 사실 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt;만 사용하게 되면 위의 문제로 고민할 필요도 없다. 그럼에도 개발자로서 &lt;strong&gt;왜?&lt;/strong&gt; 라는 질문을 해보는 것이 중요하다. 위 사실을 알게 되었든 아니든 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt;만을 사용하면 이런 문제를 고민할 필요는 없겠지만 그럼에도 동등비교연산의 매커니즘을 적확히 파악하여 다음과 같은 상황에 대한 처리방법을 생각 할 수 있었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;만약 어떤 값에 대하여 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;이 들어올지 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;가 들어올지 확실하지 않은 상황에서,
&lt;code class=&quot;language-text&quot;&gt;if (value == null) {}&lt;/code&gt;과 같은 방법으로 &lt;code class=&quot;language-text&quot;&gt;nullish&lt;/code&gt;한 값에 대한 처리가 가능해 진다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[이터러블/이터레이터/제네레이터]]></title><description><![CDATA[자바스크립트 공부중 어려웠던 내용을 복습해 보려고 한다. 그 중 하나가 Iterable / Iterator / Generator 였다. 패스트캠퍼스 Nodejs…]]></description><link>https://kimjeongwonn.github.io/이터러블-이터레이터-제네레이터/</link><guid isPermaLink="false">https://kimjeongwonn.github.io/이터러블-이터레이터-제네레이터/</guid><pubDate>Sun, 14 Jun 2020 02:04:07 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트 공부중 어려웠던 내용을 복습해 보려고 한다. 그 중 하나가 Iterable / Iterator / Generator 였다. 패스트캠퍼스 Nodejs 올인원 패키지에서는 제대로 설명해 주지 않아서 조금 아쉬웠다. 강좌의 분량을 생각하면 어쩔 수 없기도 했지만, 이해하는데 꽤나 시간을 많이 들였다. 물론 지금도 바로 설명하라고 하면 한참을 어버버 거릴 것 같다. 지식의 상태로 있는 내용들을 내것으로 만드는 건 반복 학습 뿐이라고 생각되기 때문에 다시 한 번 정리해 본다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5&gt;참고 자료 :&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://poiemaweb.com/es6-iteration-for-of&quot;&gt;https://poiemaweb.com/es6-iteration-for-of&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://poiemaweb.com/es6-generator&quot;&gt;https://poiemaweb.com/es6-generator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Iteration Protocol&lt;/h1&gt;
&lt;p&gt;ES6에서 새로 도입된 데이터 컬렉션 객체(대표적으로 Array)를 순회하기 위한 Protocol(정의된 규칙)이다. 이 프로토콜을 준수한 객체만이 for of 문으로 순회할 수 있고 Spread문법의 피연산자가 될 수 있다. Iteration Protocol은 Iterable Protocol과 Iterator Protocol을 총칭한다.&lt;/p&gt;
&lt;h2&gt;1. 이터러블(Iterable)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Symbol.iterator를 키로 갖고있는 메소드를 가지고 있는 객체를 말한다.&lt;/strong&gt; 별도로 Symbol.iterator를 키로 하여 메소드를 정의해 주거나 프로토타입 상속을 통해서 Symbol.iterator를 키로 갖고있는 메소드를 갖고 있다면 Iterable Protocol의 조건을 충족하여 Iterable이라고 할 수 있다. Iterable객체는 for of문으로 순회할 수 있고 Spread문법의 피연산자로 사용할 수 있다. 대표적으로 Array 객체가 있다. &lt;em&gt;(ES9부터는 Object도 피연산자로 사용할 수 있다.)&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; array &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Symbol&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;iterator &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//true&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; item &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;item&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.1 빌트인 이터러블&lt;/h3&gt;
&lt;p&gt;ES6를 기준으로 이터러블을 지원하는 객체는 아래와 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Array, String, Map, Set, TypedArray(Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array), DOM data structure(NodeList, HTMLCollection), &lt;em&gt;Arguments&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2. 이터레이터(Iterator)&lt;/h2&gt;
&lt;p&gt;이터러블 객체의 Symbol.iterator 메소드를 호출하면 Iterator객체를 반환한다. 반환된 Iterator객체는 next메소드를 소유하고 있으며 next메소드를 호출할 때 iterator result 객체를 반환한다면 Iterator Protocol을 충족하여 Iterator라고 할 수 있다. iterator result 객체는 value와 done 프로퍼티를 갖고 있으며, value는 현재 순회하는 값을 갖고 있고 done은 순회가 언제 끝나는지 알려준다. next메소드는 반복적을 호출되다가 모든 요소를 순회하게 되면 value프로퍼티는 undefined, done프로퍼티는 true가 되며 순회를 중단한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; array &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; iterator &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; array&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;Symbol&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;itrator&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//Symbol.itrator를 호출해서 반환된 iterator를 받는다.&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;iterator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//반복&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//{ value: 1, done: false }&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//{ value: 2, done: false }&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//{ value: 3, done: false }&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//{ value: 4, done: false }&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//{ value: 5, done: false }&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//{ value: undefined, done: true }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images.velog.io/images/kimjeongwonn/post/32adbcb3-27a2-4ddc-97e1-b3b0ed4f2c1b/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;3. 이터러블 객체 순회하기&lt;/h2&gt;
&lt;p&gt;Iteration Protocol을 준수하는 객체를 순회하는 반복문/연산자가 있는데 대표적으로는 for of문이 있다. 이런 반복문/연산자들은 Iterable 객체에서 Iterator를 조작하여 iterator result를 참조해 명령을 실행한다.&lt;/p&gt;
&lt;h3&gt;3.1 for of문&lt;/h3&gt;
&lt;p&gt;for of문은 해당하는 객체의 Iterator를 통해 받는 iterator result객체의 done프로퍼티가 true가 될 때까지 value프로퍼티의 값을 순회하며 변수에 할당한다. 위의 빌트인 이터러블안의 객체는 모두 순환이 가능하기 때문에 문자열도 순환이 가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//배열&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; i &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//1 2 3 4 5&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//문자열&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; i &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;abcde&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//&apos;a&apos; &apos;b&apos; &apos;c&apos; &apos;d&apos; &apos;e&apos;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4. 제네레이터(Generator)&lt;/h2&gt;
&lt;p&gt;직접 이터러블 객체를 만들 수도 있다. 먼저, Iteration Protocol에 맞춰 &lt;em&gt;value와 done프로퍼티를 return하는 next메소드를 return하는 Symbol.iterator 메소드&lt;/em&gt; 를 직접 작성하여 객체에 할당해주는 방법도 있지만 제네레이터 함수를 이용해 더 쉽게 이터러블 객체를 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;아래 예제를 통해 제네레이터의 생성과 순회를 살펴보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;//function* 을 통해 제네레이터 함수를 만들 수 있다. (화살표 함수는 사용할 수 없다.)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; 
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Point 1&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
  &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
  &lt;span class=&quot;token comment&quot;&gt;//next 메소드를 호출하면 yield까지의 명령이 처리된 뒤, yield에서 반환되는 값이 iterator result 객체의 value에 할당된다. 그 뒤 다음 next메소드가 호출 될 때 까지 대기한다.&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Point 2&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Point 3&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;done&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//모든 순회가 끝나고 done 프로퍼티가 true가 된다.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; generatorObj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;/* 제네레이터 함수를 호출해서 제네레이터 객체를 생성한다.
제네레이터를 통해 생성된 객체는 이터러블이면서 이터레이터이기 때문에 굳이 Symbol.iterator를 호출하지 않아도 next메소드를 통해 순회할 수 있다. */&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; i &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; generatorObj &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//이터러블 객체이기 때문에 for of 문으로 바로 순회가 가능하다. &lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//물론 이터레이터이기도 하기 때문에 next메소드를 호출하여 원하는 시점에서 호출이 가능하다.&lt;/span&gt;

generatorObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//next를 통해 순회하게 되면 yield로 반환된 값을 value프로퍼티의 값으로 갖는 iterator result 객체가 반환된다. 제네레이터 함수 안에 마지막 yield가 끝난 뒤에는 done프로퍼티는 true가 되며 순회가 종료된다.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 예제의 &lt;strong&gt;제네레이터 함수&lt;/strong&gt;를 통해 &lt;strong&gt;&lt;em&gt;이터러블이면서 이터레이터인&lt;/em&gt; 제네레이터 객체&lt;/strong&gt;를 생성하고 생성된 제네레이터 객체는 이터러블 처럼 for of를 통해 순회하거나 이터레이터 처럼 next메소드를 통해 순회할 수 있다.&lt;/p&gt;
&lt;h3&gt;4.1 제네레이터에 인수를 전달하여 호출하기&lt;/h3&gt;
&lt;p&gt;제네레이터 함수는 함수이기 때문에 인자를 받아 제네레이터 객체를 생성할 수 있다.
다음과 같이 인자로 입력받은 횟수만큼 반복하는 제네레이터를 생성해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt;n &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;current number : &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;i&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;, last number : &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;n&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; genObj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//10번 순회할 수 있는 제네레이터 오브젝트를 생성&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//반복 호출하면 아래와 같은 콘솔을 볼 수 있다.&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/*
제네레이터 함수 안에 있는 console.log가 출력
current number : 1, last number : 10
next메소드가 반환된 iterble result가 console.log를 통해 출력
{value: 0, done: false}
... 계속 순회하다가 인자로 넣은 마지막 숫자에 도달하면 아래와 같이 done이 true가 되어 순회를 종료
current number : 10, last number : 10
{value: 10, done: false}
{value: undefined, done: true}
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.2 next메소드에 인수를 전달하여 제네레이터 호출하기&lt;/h3&gt;
&lt;p&gt;제네레이터는 이터레이터와는 다르게 next메소드에 인자를 전달하면 제네레이터 함수의 yield에 할당되어 작동한다. 이를 통해 좀 더 유연하게 제네레이터를 활용할 수 있다.
아래의 예제를 통해 인자가 어떻게 전달되는지 알 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; n&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
 
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; genObj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//0 으로 초기값 지정&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//제네레이터 함수 시작 =&gt; value:0&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//yield에 1을 전달 이후 함수 다시시작&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//반복&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//더이상 yield가 없기 때문에 종료&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//{ value: undefined, done: true }&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/*
{ value: 0, done: false }
{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }

*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;next메소드에 인수가 있을 경우에는 yield는 두가지 역할을 하게 된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;value값 반환&lt;/li&gt;
&lt;li&gt;next의 인수를 변수에 할당&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;먼저 res에 리터럴을 할당하기 위해서 자바스크립트가 yield n을 처리하게 된다. &lt;strong&gt;그 과정에서 yield가 처리되면서 다음 next까지 함수가 일시정지 되게 된다.&lt;/strong&gt; 그리고 다음 next가 호출 될 때 받은 인자를 yield가 반환하여 res변수에 할당하게 된다. 그리고 다시 다음 yield까지 실행한 뒤 일시정지 된다. 이 과정이 마지막 yield까지 반복된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.velog.io/images/kimjeongwonn/post/ccdb0940-e2fd-4b12-b7bb-f25a8bb52570/image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;4.3 return을 통해 제네레이터를 강제 종료&lt;/h3&gt;
&lt;p&gt;제네레이터 함수 안에서 return이 실행되는 즉시 done은 true가 되고 return에서 반환된 값을 가진 iterator result 객체가 반환된 뒤 제네레이터가 종료된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;end&apos;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; genObj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;genObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//반복&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;/*
{value: 0, done: false}
{value: 1, done: false}
{value: 2, done: false}
{value: 3, done: false}
{value: 4, done: false}
{value: 5, done: false} //for of 등을 통한 순회에서는 여기까지만 순회한다.
{value: &apos;end&apos;, done: true}
{value: undefined, done: true}
...
*/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;return에서 값을 반환하면서 동신에 done이 true가 되기 때문에 for of문 들을 통한 순회에서는 그 전의 값까지만 순회한다.&lt;/p&gt;
&lt;h3&gt;4.4 비동기 처리&lt;/h3&gt;
&lt;p&gt;함수의 비동기 처리도 제네레이터를 통해 구현할 수 있지만 ES8의 async/await가 완전히 그 기능을 대체하고 있으니 이곳에 설명은 생략한다.&lt;/p&gt;
&lt;h1&gt;마치며&lt;/h1&gt;
&lt;p&gt;첫 번째 복습기록이다. 내가 이해가 안되었던 부분들을 최대한 이해할 수 있도록 풀어 썼다. 개인적으로는 next메소드에 인수를 넣어 호출할 때 어째서 인수로 넣은 값이 res에 할당된 뒤 console.log로 출력되는지 계속 고민했고, 그렇게 알게 된 내용을 좀 더 자세히 서술했다. 물론 다른 사람들은 당연하게 이해하고 넘어갈 수 있는 부분이었더라도 나는 저 부분이 쉽게 넘어가지지 않았다. 또한 나도 이렇게 복습/복기를 하면서 새로운 사실도 알게되었다. 현재는 React를 배우고 있는데 당연한 듯이 Object 객체에 Spread 연산을 쓰는 강의를 보면서 Object는 이터러블이 아닌데 어떻게 Spread연산이 동작하나 싶었는데 ES9부터 Object에서 Spread연산이 작동한다는 사실도 알게되었다.&lt;/p&gt;</content:encoded></item></channel></rss>