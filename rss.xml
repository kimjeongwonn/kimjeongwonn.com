<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[kimjeongwonn]]></title><description><![CDATA[프론트엔드 개발 공부 블로그]]></description><link>https://kimjeongwonn.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Thu, 12 Aug 2021 11:46:39 GMT</lastBuildDate><item><title><![CDATA[자바스크립트의 핵심 '실행 컨텍스트']]></title><description><![CDATA[자바스크립트를 공부하면서 개인적으로 자바스크립트에서 가장 중요한 개념을 꼽자면 를 꼽는다. 자바스크립트의 핵심 개념들을 나열 해 보라고 한다면 보통 프로토타입, this…]]></description><link>https://kimjeongwonn.github.io/자바스크립트의-핵심-실행컨텍스트/</link><guid isPermaLink="false">https://kimjeongwonn.github.io/자바스크립트의-핵심-실행컨텍스트/</guid><content:encoded>&lt;p&gt;자바스크립트를 공부하면서 개인적으로 자바스크립트에서 가장 중요한 개념을 꼽자면 &lt;code class=&quot;language-text&quot;&gt;실행 컨텍스트&lt;/code&gt;를 꼽는다. 자바스크립트의 핵심 개념들을 나열 해 보라고 한다면 보통 프로토타입, this 바인딩, 호이스팅, 렉시컬 스코프, 클로저, 이벤트 루프등을 떠올릴 수 있고 그 중에서도 앞의 개념들을 관통하는 가장 핵심적인 개념이 &lt;code class=&quot;language-text&quot;&gt;실행 컨텍스트&lt;/code&gt;이다.&lt;/p&gt;
&lt;h2&gt;실행 환경&lt;/h2&gt;
&lt;p&gt;실행 컨텍스트(EC: Execution Context)는 실행 컨텍스트 스택에서 구성된다. 그리고 모든 코드는 EC 안에서 작동한다. 코드가 평가되기 위해서 자바스크립트 엔진은 EC를 생성한 뒤 코드를 평가하는데 EC가 생성되는 상황은 크게 세가지가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;전역 코드의 실행 → 전역 EC 생성&lt;/li&gt;
&lt;li&gt;함수의 실행 → 함수 EC 생성&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt;코드의 실행 → eval EC 생성&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;당연한 얘기지만 자바스크립트 코드를 실행하면 먼저 전역 코드를 실행하기 때문에 반드시 전역 실행 콘텍스트가 생성된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;실행 컨텍스트 스택과 콜 스택은 같은 의미이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;EC가 생성되면 생성 단계와 실행 단계를 거친 뒤 코드를 실행하게 된다.&lt;/p&gt;
&lt;p&gt;-작성중-&lt;/p&gt;</content:encoded></item><item><title><![CDATA[자바스크립트 동등비교연산자 (==)]]></title><description><![CDATA[…]]></description><link>https://kimjeongwonn.github.io/자바스크립트-동등비교연산자-(==)/</link><guid isPermaLink="false">https://kimjeongwonn.github.io/자바스크립트-동등비교연산자-(==)/</guid><pubDate>Wed, 11 Aug 2021 10:36:56 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트에서는 비교연산이 두가지 있다. &lt;code class=&quot;language-text&quot;&gt;==&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt; 로 전자는 동등비교연사자, 후자는 일치비교연산자라고 부르기도 한다. (일단 나는 그렇게 부른다.) 대부분의 자바스크립트 개발자들은 두 비교연산자의 차이점은 비교연산시에 동적으로 타이핑을 하느냐로 알고 있을 것이고, 나도 그랬었다. 그렇다면 아래 표현식들의 결과는 어떻게 나올까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;결론부터 말하자면 둘 다 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;가 나온다. 우리는 동등 비교연산&lt;code class=&quot;language-text&quot;&gt;==&lt;/code&gt;을 하게되면 양쪽의 피연산자의 값을 형변환을 이용한 뒤 일치연산을 하는 것으로 알고있다. 그렇다면 일반적으로 아래와 같은 방식으로 비교할 것이라고 기대한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// []를 boolean으로 형변환 한다&lt;/span&gt;
&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true를 반환한다&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// null을 0으로 형변환 한다&lt;/span&gt;
&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true를 반환한다&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그런데 왜 둘 다 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;가 나오는 것일까? 정답은 자바스크립트는 동등 비교 연산시에 ECMAScript에서 지정한 &lt;a href=&quot;https://262.ecma-international.org/5.1/#sec-11.9.3&quot;&gt;동등 비교 연산 알고리즘&lt;/a&gt;을 통해 형변환을 진행하기 때문이다. 그 중에는 다음과 같은 내용이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.&lt;/li&gt;
&lt;li&gt;If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그렇다. 양쪽의 피연산자 중 하나가 &lt;strong&gt;boolean일 경우 number로 형변환을 한 뒤 비교한다&lt;/strong&gt;는 내용이다. 왜 동등 비교연산에서 이런 짓을 하는지는 브렌던 아이크씨가 알겠지만, 일단은 동등 비교연산에서는 위의 알고리즘을 따른다는 것이다. 그럼 다시 &lt;code class=&quot;language-text&quot;&gt;[] == true&lt;/code&gt;가 어떻게 작동하는지 생각 해 보자&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// boolean인 true를 number로 형변환 한다&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true를 number로 바꾸면 1이다. 이제 빈 배열을 number로 형변환 한다&lt;/span&gt;
&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 빈 배열을 number로 바꾸면 0이 나온다 (1이 아니다) 결국 0과 1을 비교하게 되어서 false가 출력된다.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런 과정을 거쳐 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;가 출력되는 것이었다. 왜 이따위로 만들었는지는 정말 모르겠다.&lt;/p&gt;
&lt;p&gt;그럼, &lt;code class=&quot;language-text&quot;&gt;null == 0&lt;/code&gt;이 안되는 이유는? 역시 동등 비교 연산 알고리즘에 답이 있다. 해당 문서에 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;에 대한 정의는 아래의 두개 뿐이다.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;If x is null and y is undefined, return true.&lt;/li&gt;
&lt;li&gt;If x is undefined and y is null, return true.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;즉 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;undifined&lt;/code&gt;는 서로 비교했을 때 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;를 반환하고 다른 연산시에는 형변환을 하지 않는다. 그렇기 때문에 &lt;code class=&quot;language-text&quot;&gt;null == 0&lt;/code&gt;을 했을 때 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;은 아예 형변환을 하지 않게되고 그대로 비교하게 되기 때문에 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;를 반환하게 된다.&lt;/p&gt;
&lt;p&gt;보통 자바스크립트를 학습할 때 동등비교연산&lt;code class=&quot;language-text&quot;&gt;==&lt;/code&gt; 보다는 일치비교연산&lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt;을 사용하라고 배우게 된다. 그리고 사실 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt;만 사용하게 되면 위의 문제로 고민할 필요도 없다. 그럼에도 개발자로서 &lt;strong&gt;왜?&lt;/strong&gt; 라는 질문을 해보는 것이 중요하다. 위 사실을 알게 되었든 아니든 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt;만을 사용하면 이런 문제를 고민할 필요는 없겠지만 그럼에도 동등비교연산의 매커니즘을 적확히 파악하여 다음과 같은 상황에 대한 처리방법을 생각 할 수 있었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;만약 어떤 값에 대하여 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;이 들어올지 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;가 들어올지 확실하지 않은 상황에서,
&lt;code class=&quot;language-text&quot;&gt;if (value == null) {}&lt;/code&gt;과 같은 방법으로 &lt;code class=&quot;language-text&quot;&gt;nullish&lt;/code&gt;한 값에 대한 처리가 가능해 진다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item></channel></rss>