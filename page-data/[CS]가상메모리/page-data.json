{"componentChunkName":"component---src-templates-blog-post-js","path":"/[CS]가상메모리/","result":{"data":{"site":{"siteMetadata":{"title":"kimjeongwonn"}},"markdownRemark":{"id":"4f6d1154-d357-55c8-8fbe-501819d3f5eb","excerpt":"리눅스에서 하나의 프로세스에 할당하는 메모리는 4GB정도 하지만 통상 시스템 물리 메모리는 8GB~32GB 정도 프로세스당 할당된 메모리는 4GB이지만 프로세스가 실제로 동작할 때 참조하는 메모리는 제한적 CPU…","html":"<ul>\n<li>리눅스에서 하나의 프로세스에 할당하는 메모리는 4GB정도</li>\n<li>하지만 통상 시스템 물리 메모리는 8GB~32GB 정도</li>\n<li>프로세스당 할당된 메모리는 4GB이지만 프로세스가 실제로 동작할 때 참조하는 메모리는 제한적</li>\n<li>CPU가 실제로 프로세스에서 참조하는 공간만 물리 메모리에 할당할 수 있음</li>\n</ul>\n<h2>아이디어</h2>\n<ul>\n<li>프로세스는 가상메모리의 주소를 사용하고, 데이터를 읽거나 쓸 때 물리 주소로 변환하여 참조할 수 있다.</li>\n<li>프로세스는 가상 주소를 먼저 참조하고 MMU에 의해 물리주소를 확인하여 물리 메모리에 접근할 수 있다</li>\n</ul>\n<h3>MMU (Memory Management Unit)</h3>\n<ul>\n<li>CPU에서 가상 주소 메모리 접근이 필요할 때, 해당 가상주소를 물리주소로 변환해 주는 하드웨어</li>\n</ul>\n<h2>페이징</h2>\n<ul>\n<li>물리메모리에 할당된 가상메모리 공간의 효율적인 관리를 위해 페이지 단위의 크기를 동일하게 설정하여 관리함</li>\n<li>하드웨어에서 지원에 따라 페이징 크기가 다름\n<ul>\n<li>인텔 x86 시스템에서는 4KB, 2MB, 1GB 단위로 지원</li>\n<li>리눅스에서는 4KB로 페이징</li>\n</ul>\n</li>\n<li>해당 페이지 단위로 가상메모리를 구분하고 해당 단위만큼 물리메모리에 할당</li>\n<li>각각에 프로세스의 PCB에는 가상주소와 물리주소의 매핑정보가 있는 Page Table 구조체를 가리키는 주소가 있음</li>\n<li>CPU에서 가상주소에 접근하면 가상주소가 포함된 페이지를 탐색 → 해당 페이지를 인덱스로 Page Table에서 접근하여 물리 메모리 주소를 받아와 해당 주소로 CPU에서 처리</li>\n</ul>\n<h3>구조</h3>\n<ul>\n<li>Page(Page Frame) : 고정된 크기의 Block (보통 4KB)</li>\n<li>가상주소 V는 두개의 영역으로 구분됨\n<ul>\n<li>p : 가상 메모리의 페이지 주소 (기준) → 12~31비트</li>\n<li>d : 페이지 내에서 참조하는 위치 (오프셋) → 0~11비트</li>\n<li>p + d : 실제 물리주소</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>프로세스가 4GB를 사용하는 이유는 32bit 시스템 내에서 4GB이내의 모든 주소를 저장할 수 있기 때문</p>\n</blockquote>\n<h3>동작</h3>\n<ul>\n<li>프로세스에서 특정 가상 주소에 엑세스하기 위해서 다음의 단계를 진행\n<ol>\n<li>해당 프로세서의 Page Table에 가상 주소가 포함된 Page번호가 있는지 확인</li>\n<li>Page번호가 있다면 해당 Page번호가 매핑된 물리 메모리 주소를 알아냄 (p’)</li>\n<li>해당 물리메모리 주소(p’) + 오프셋(d)를 계산하여 실제 물리 메모리 주소를 확인</li>\n</ol>\n</li>\n<li>Page Table에 저장된 페이지에 Valid-Invalid Bit를 저장해서 물리메모리에 해당 페이지가 들어가 있는지 바로 확인할 수 있음</li>\n</ul>\n<h3>페이징 시스템과 MMU</h3>\n<ul>\n<li>CPU에서 가상주소 접근하면 MMU를 통해 물리주소를 받아올 수 있음</li>\n<li>프로세스를 생성하면 CR3 레지스터에 Page Table의 Base주소를 저장</li>\n<li>MMU는 CPU가 요청한 가상 주소에 해당하는 물리주소를 Page Table에 접근하여 가져옴</li>\n</ul>\n<h2>다중 단계 페이징 시스템</h2>\n<ul>\n<li>프로세스에서 할당된 모든 가상 메모리에 대한 페이지 정보를 Page Table에 저장하는 것은 굉장한 낭비</li>\n<li>페이지 정보를 단계를 나눠 생성하여 필요한 페이지만 생성하여 자원을 절약</li>\n<li>Page Table을 Directory로 한 단계 더 거쳐 접근하도록 하여 실제 존재하는 Page Table만 관리할 수 있도록 함</li>\n<li>Page Directory는 실제로 존재하는 Page Table만을 연결하여 만듬</li>\n</ul>\n<h2>MMU와 TLB</h2>\n<ul>\n<li>MMU가 동작할 때 데이터의 이동이 잦음\n<ul>\n<li>CPU에서 가상주소로 요청 → MMU에서 PageTable에 접근하여 물리 주소 획득 → 획득한 물리 메모리 주소로 가서 데이터 획득 → CPU에 획득한 데이터 전달</li>\n</ul>\n</li>\n<li>해당 동작의 반복을 줄이기 위해 TLB를 통해 가상주소에 대한 물리주소를 캐싱하여 동작을 줄일 수 있음\n<ul>\n<li>CPU에서 가상주소를 요청했을 때 먼저 TLB를 확인하여 캐싱된 물리주소가 있다면 바로 처리</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[CS] 가상메모리","date":"2021-08-30T11:11:09.000Z","description":null}},"previous":{"fields":{"slug":"/[CS]스레드/"},"frontmatter":{"title":"[CS] 스레드"}},"next":null},"pageContext":{"id":"4f6d1154-d357-55c8-8fbe-501819d3f5eb","previousPostId":"bd42d8ef-98f2-5fd4-a28b-01b6b60dca46","nextPostId":null}},"staticQueryHashes":["2841359383"]}